<?xml version="1.0" encoding="UTF-8" ?>
<project firstLayout="">
    <gdVersion build="92" major="4" minor="0" revision="1" />
    <properties folderProject="false" linuxExecutableFilename="" macExecutableFilename="" packageName="com.example.gamename" useExternalSourceFiles="true" winExecutableFilename="" winExecutableIconFile="">
        <name>Projet</name>
        <author></author>
        <windowWidth>800</windowWidth>
        <windowHeight>600</windowHeight>
        <latestCompilationDirectory>C:\Users\aurelien\Desktop\GD\nodeJS\app\export</latestCompilationDirectory>
        <maxFPS>60</maxFPS>
        <minFPS>10</minFPS>
        <verticalSync>false</verticalSync>
        <extensions>
            <extension name="BuiltinObject" />
            <extension name="BuiltinAudio" />
            <extension name="BuiltinVariables" />
            <extension name="BuiltinTime" />
            <extension name="BuiltinMouse" />
            <extension name="BuiltinKeyboard" />
            <extension name="BuiltinJoystick" />
            <extension name="BuiltinCamera" />
            <extension name="BuiltinWindow" />
            <extension name="BuiltinFile" />
            <extension name="BuiltinNetwork" />
            <extension name="BuiltinScene" />
            <extension name="BuiltinAdvanced" />
            <extension name="Sprite" />
            <extension name="BuiltinCommonInstructions" />
            <extension name="BuiltinCommonConversions" />
            <extension name="BuiltinStringInstructions" />
            <extension name="BuiltinMathematicalTools" />
            <extension name="BuiltinExternalLayouts" />
            <extension name="TextObject" />
            <extension name="TextEntryObject" />
            <extension name="TiledSpriteObject" />
        </extensions>
        <platforms>
            <platform name="GDevelop C++ platform" />
            <platform name="GDevelop JS platform" />
        </platforms>
        <currentPlatform>GDevelop C++ platform</currentPlatform>
    </properties>
    <resources>
        <resources>
            <resource alwaysLoaded="false" file="Assets/images/Block-Normal.png" kind="image" name="Block-Normal.png" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/Character Boy.png" kind="image" name="Character Boy.png" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/Character Cat Girl.png" kind="image" name="Character Cat Girl.png" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/Character Horn Girl.png" kind="image" name="Character Horn Girl.png" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/Character Pink Girl.png" kind="image" name="Character Pink Girl.png" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/Character Princess Girl.png" kind="image" name="Character Princess Girl.png" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/normal.jpg" kind="image" name="normal.jpg" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/select.jpg" kind="image" name="select.jpg" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/use42232.png" kind="image" name="use42232.png" smoothed="true" userAdded="true" />
            <resource alwaysLoaded="false" file="Assets/images/XMLID_44_.png" kind="image" name="XMLID_44_.png" smoothed="true" userAdded="true" />
        </resources>
        <resourceFolders />
    </resources>
    <objects />
    <objectsGroups />
    <variables>
        <variable name="socket" value="0" />
        <variable name="server_message" value='&quot;bateau&quot;' />
        <variable name="joueurs">
            <children>
                <variable name="joueur_1">
                    <children>
                        <variable name="posX" value="100" />
                        <variable name="posY" value="100" />
                        <variable name="pseudo" value="Tims" />
                    </children>
                </variable>
                <variable name="joueur_2">
                    <children>
                        <variable name="posX">
                            <children />
                        </variable>
                        <variable name="posY" value="0" />
                        <variable name="pseudo" value="Tims" />
                    </children>
                </variable>
            </children>
        </variable>
        <variable name="selection" value="0" />
        <variable name="joueur_actuel" value='&quot;no_one&quot;' />
    </variables>
    <layouts>
        <layout b="209" disableInputWhenNotFocused="true" mangledName="creation_95joueur" name="creation_joueur" oglFOV="90.000000" oglZFar="500.000000" oglZNear="1.000000" r="209" standardSortMethod="true" stopSoundsOnStartup="true" title="" v="209">
            <uiSettings grid="false" gridB="255" gridG="180" gridHeight="32" gridOffsetX="0" gridOffsetY="0" gridR="158" gridWidth="32" snap="true" windowMask="false" zoomFactor="1.000000" />
            <objectsGroups />
            <variables />
            <instances>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="txt_pseudo" width="0.000000" x="230.000000" y="164.500000" zOrder="3">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="input_pseudo" width="0.000000" x="254.000000" y="-53.499992" zOrder="2">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="true" height="42.000000" layer="" locked="false" name="input" width="214.000000" x="218.000000" y="154.500000" zOrder="1">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables>
                        <variable name="type" value="input_pseudo" />
                    </initialVariables>
                </instance>
                <instance angle="0.000000" customSize="true" height="62.000000" layer="" locked="false" name="input" width="224.000000" x="258.000000" y="420.500000" zOrder="4">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables>
                        <variable name="type" value="create_profile" />
                    </initialVariables>
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="txt_var" width="0.000000" x="282.000000" y="440.500000" zOrder="5">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables>
                        <variable name="text" value="OK" />
                    </initialVariables>
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="debug" width="0.000000" x="188.000000" y="303.000031" zOrder="6">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="switch_scene" width="0.000000" x="714.000000" y="98.499985" zOrder="7">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="output_server" width="0.000000" x="222.000000" y="214.500000" zOrder="8">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
            </instances>
            <objects>
                <object name="input_pseudo" type="TextEntryObject::TextEntry">
                    <variables />
                    <behaviors />
                </object>
                <object bold="false" italic="false" name="txt_pseudo" smoothed="true" type="TextObject::Text" underlined="false">
                    <variables />
                    <behaviors />
                    <string>Text</string>
                    <font></font>
                    <characterSize>20</characterSize>
                    <color b="255" g="255" r="255" />
                </object>
                <object name="input" type="Sprite">
                    <variables>
                        <variable name="Select" value="0" />
                    </variables>
                    <behaviors />
                    <animations>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="normal.jpg">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="25.000000" y="25.000000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="50.000000" />
                                                    <vertice x="0.000000" y="50.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="select.jpg">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="25.000000" y="25.000000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="50.000000" />
                                                    <vertice x="0.000000" y="50.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                    </animations>
                </object>
                <object bold="false" italic="false" name="txt_var" smoothed="true" type="TextObject::Text" underlined="false">
                    <variables />
                    <behaviors />
                    <string>Text</string>
                    <font></font>
                    <characterSize>20</characterSize>
                    <color b="255" g="255" r="255" />
                </object>
                <object bold="false" italic="false" name="debug" smoothed="true" type="TextObject::Text" underlined="false">
                    <variables />
                    <behaviors />
                    <string>Text</string>
                    <font></font>
                    <characterSize>20</characterSize>
                    <color b="255" g="255" r="255" />
                </object>
                <object name="switch_scene" type="Sprite">
                    <variables />
                    <behaviors />
                    <animations>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="use42232.png">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="35.500000" y="14.500000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="71.000000" y="0.000000" />
                                                    <vertice x="71.000000" y="29.000000" />
                                                    <vertice x="0.000000" y="29.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                    </animations>
                </object>
                <object bold="false" italic="false" name="output_server" smoothed="true" type="TextObject::Text" underlined="false">
                    <variables />
                    <behaviors />
                    <string>Entrez un pseudo</string>
                    <font></font>
                    <characterSize>20</characterSize>
                    <color b="255" g="255" r="255" />
                </object>
            </objects>
            <events>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="SourisSurObjet" />
                            <parameters>
                                <parameter>switch_scene</parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="Scene" />
                            <parameters>
                                <parameter></parameter>
                                <parameter>&quot;jeux&quot;</parameter>
                                <parameter>true</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="0" g="255" r="255" textB="0" textG="0" textR="0" />
                    <comment>Importations</comment>
                    <comment2>Import</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Link</type>
                    <include end="-1" includeAll="true" start="-1" />
                    <target>Evenements externes</target>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="109" g="230" r="255" textB="0" textG="0" textR="0" />
                    <comment>Initialisation des inputs sur OFF</comment>
                    <comment2>Initialisation of inputs to OFF</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="true" value="VarObjetTxt" />
                            <parameters>
                                <parameter>input</parameter>
                                <parameter>type</parameter>
                                <parameter>=</parameter>
                                <parameter>&quot;input_pseudo&quot;</parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="TextEntryObject::Activate" />
                            <parameters>
                                <parameter>input_pseudo</parameter>
                                <parameter>non</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="0" g="128" r="255" textB="0" textG="0" textR="0" />
                    <comment>Test envoie donnée to serveur.js</comment>
                    <comment2></comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="SourisSurObjet" />
                            <parameters>
                                <parameter>input</parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                        <condition>
                            <type inverted="false" value="SourisBouton" />
                            <parameters>
                                <parameter></parameter>
                                <parameter>Left</parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::Standard</type>
                            <conditions>
                                <condition>
                                    <type inverted="false" value="VarObjetTxt" />
                                    <parameters>
                                        <parameter>input</parameter>
                                        <parameter>type</parameter>
                                        <parameter>=</parameter>
                                        <parameter>&quot;input_pseudo&quot;</parameter>
                                    </parameters>
                                    <subConditions />
                                </condition>
                            </conditions>
                            <actions />
                            <events>
                                <event disabled="false" folded="false">
                                    <type>BuiltinCommonInstructions::Standard</type>
                                    <conditions>
                                        <condition>
                                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                                            <parameters />
                                            <subConditions />
                                        </condition>
                                    </conditions>
                                    <actions />
                                    <events />
                                </event>
                            </events>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions />
                    <actions />
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment>Clique de sélection sur un bouton/input</comment>
                    <comment2>Selection on a button or input</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="SourisBouton" />
                            <parameters>
                                <parameter></parameter>
                                <parameter>Left</parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::Standard</type>
                            <conditions>
                                <condition>
                                    <type inverted="false" value="BuiltinCommonInstructions::Once" />
                                    <parameters />
                                    <subConditions />
                                </condition>
                            </conditions>
                            <actions />
                            <events>
                                <event disabled="false" folded="false">
                                    <type>BuiltinCommonInstructions::Standard</type>
                                    <conditions>
                                        <condition>
                                            <type inverted="true" value="SourisSurObjet" />
                                            <parameters>
                                                <parameter>input</parameter>
                                                <parameter></parameter>
                                                <parameter></parameter>
                                                <parameter></parameter>
                                            </parameters>
                                            <subConditions />
                                        </condition>
                                    </conditions>
                                    <actions />
                                    <events>
                                        <event disabled="false" folded="false">
                                            <type>BuiltinCommonInstructions::Standard</type>
                                            <conditions />
                                            <actions>
                                                <action>
                                                    <type inverted="false" value="ModVarGlobalTxt" />
                                                    <parameters>
                                                        <parameter>selection</parameter>
                                                        <parameter>=</parameter>
                                                        <parameter>&quot;none&quot;</parameter>
                                                    </parameters>
                                                    <subActions />
                                                </action>
                                            </actions>
                                            <events />
                                        </event>
                                    </events>
                                </event>
                                <event disabled="false" folded="false">
                                    <type>BuiltinCommonInstructions::Standard</type>
                                    <conditions>
                                        <condition>
                                            <type inverted="false" value="SourisSurObjet" />
                                            <parameters>
                                                <parameter>input</parameter>
                                                <parameter></parameter>
                                                <parameter></parameter>
                                                <parameter></parameter>
                                            </parameters>
                                            <subConditions />
                                        </condition>
                                    </conditions>
                                    <actions />
                                    <events>
                                        <event disabled="false" folded="false">
                                            <type>BuiltinCommonInstructions::Standard</type>
                                            <conditions>
                                                <condition>
                                                    <type inverted="false" value="VarObjetTxt" />
                                                    <parameters>
                                                        <parameter>input</parameter>
                                                        <parameter>type</parameter>
                                                        <parameter>=</parameter>
                                                        <parameter>&quot;input_pseudo&quot;</parameter>
                                                    </parameters>
                                                    <subConditions />
                                                </condition>
                                            </conditions>
                                            <actions>
                                                <action>
                                                    <type inverted="false" value="ModVarGlobalTxt" />
                                                    <parameters>
                                                        <parameter>selection</parameter>
                                                        <parameter>=</parameter>
                                                        <parameter>&quot;input_pseudo&quot;</parameter>
                                                    </parameters>
                                                    <subActions />
                                                </action>
                                            </actions>
                                            <events />
                                        </event>
                                        <event disabled="false" folded="false">
                                            <type>BuiltinCommonInstructions::Standard</type>
                                            <conditions>
                                                <condition>
                                                    <type inverted="false" value="VarObjetTxt" />
                                                    <parameters>
                                                        <parameter>input</parameter>
                                                        <parameter>type</parameter>
                                                        <parameter>=</parameter>
                                                        <parameter>&quot;create_profile&quot;</parameter>
                                                    </parameters>
                                                    <subConditions />
                                                </condition>
                                            </conditions>
                                            <actions>
                                                <action>
                                                    <type inverted="false" value="ModVarGlobalTxt" />
                                                    <parameters>
                                                        <parameter>selection</parameter>
                                                        <parameter>=</parameter>
                                                        <parameter>&quot;create_profile&quot;</parameter>
                                                    </parameters>
                                                    <subActions />
                                                </action>
                                            </actions>
                                            <events />
                                        </event>
                                    </events>
                                </event>
                            </events>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="VarGlobalTxt" />
                            <parameters>
                                <parameter>selection</parameter>
                                <parameter>=</parameter>
                                <parameter>&quot;input_pseudo&quot;</parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="TextObject::String" />
                            <parameters>
                                <parameter>txt_pseudo</parameter>
                                <parameter>=</parameter>
                                <parameter>input_pseudo.String()</parameter>
                            </parameters>
                            <subActions />
                        </action>
                        <action>
                            <type inverted="false" value="TextEntryObject::Activate" />
                            <parameters>
                                <parameter>input_pseudo</parameter>
                                <parameter>oui</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="VarGlobalTxt" />
                            <parameters>
                                <parameter>selection</parameter>
                                <parameter>=</parameter>
                                <parameter>&quot;create_profile&quot;</parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                        <condition>
                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                            <parameters />
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="ModVarGlobalTxt" />
                            <parameters>
                                <parameter>joueur_actuel</parameter>
                                <parameter>=</parameter>
                                <parameter>txt_pseudo.String()</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>joueurs_actuel = variables.get(&quot;joueur_actuel&quot;);&#x0D;&#x0A;socket.emit(&apos;creation_joueur&apos;, joueurs_actuel.getAsString());</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="0" g="128" r="255" textB="0" textG="0" textR="0" />
                    <comment>TEST</comment>
                    <comment2></comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions />
                    <actions>
                        <action>
                            <type inverted="false" value="ModVarGlobalTxt" />
                            <parameters>
                                <parameter>joueurs.joueur_3.pseudo</parameter>
                                <parameter>=</parameter>
                                <parameter>&quot;Bouh&quot;</parameter>
                            </parameters>
                            <subActions />
                        </action>
                        <action>
                            <type inverted="false" value="TextObject::String" />
                            <parameters>
                                <parameter>debug</parameter>
                                <parameter>=</parameter>
                                <parameter>GlobalVariableString(joueurs.joueur_3.pseudo)</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                            <parameters />
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>var joueurs = variables.get(&quot;joueurs&quot;);&#x0D;&#x0A;var child = joueurs.getAllChildren();&#x0D;&#x0A;&#x0D;&#x0A;var count = 0;&#x0D;&#x0A;for (var k in child) {&#x0D;&#x0A; if (child.hasOwnProperty(k)) {&#x0D;&#x0A; ++count;&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;console.log(&quot;Nombre d&apos;enfants de Joueurs : &quot; + count );&#x0D;&#x0A;&#x0D;&#x0A;nb_joueurs = variables.get(&quot;nb_joueurs&quot;);&#x0D;&#x0A;nb_joueurs.setString(count);</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>socket.on(&apos;reception_liste_joueurs&apos;, function(message) {&#x0D;&#x0A;&#x09;&#x0D;&#x0A;&#x09;var liste_joueurs = variables.get(&quot;liste_joueurs&quot;);&#x0D;&#x0A;&#x09;liste_joueurs.setString(message);&#x0D;&#x0A;&#x09;console.log(&quot;Liste des joueurs : &quot; + liste_joueurs.getAsString());&#x0D;&#x0A;&#x0D;&#x0A;})</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>socket.on(&apos;message_error&apos;, function(message) {&#x0D;&#x0A;&#x09;message_error = variables.get(&quot;message_error&quot;);&#x0D;&#x0A;&#x09;message_error.setString(message);&#x0D;&#x0A;&#x09;console.log(&quot;text pseudo pris&quot;);&#x0D;&#x0A;})</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions />
                    <actions>
                        <action>
                            <type inverted="false" value="TextObject::String" />
                            <parameters>
                                <parameter>output_server</parameter>
                                <parameter>=</parameter>
                                <parameter>GlobalVariableString(message_error)</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions />
                    <actions />
                    <events />
                </event>
            </events>
            <layers>
                <layer name="" visibility="true">
                    <cameras>
                        <camera defaultSize="true" defaultViewport="true" height="0.000000" viewportBottom="1.000000" viewportLeft="0.000000" viewportRight="1.000000" viewportTop="0.000000" width="0.000000" />
                    </cameras>
                    <effects />
                </layer>
            </layers>
            <behaviorsSharedData />
        </layout>
        <layout b="209" disableInputWhenNotFocused="true" mangledName="jeux" name="jeux" oglFOV="90.000000" oglZFar="500.000000" oglZNear="1.000000" r="209" standardSortMethod="true" stopSoundsOnStartup="true" title="" v="209">
            <uiSettings grid="false" gridB="255" gridG="180" gridHeight="32" gridOffsetX="0" gridOffsetY="0" gridR="158" gridWidth="32" snap="true" windowMask="false" zoomFactor="1.000000" />
            <objectsGroups />
            <variables>
                <variable name="loop_count" value="0" />
            </variables>
            <instances>
                <instance angle="0.000000" customSize="true" height="43.000000" layer="" locked="false" name="btn" width="169.000000" x="25.000013" y="30.499954" zOrder="1">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables>
                        <variable name="type" value="send_data" />
                    </initialVariables>
                </instance>
                <instance angle="0.000000" customSize="false" height="134.000000" layer="" locked="false" name="text_1" width="282.000000" x="43.999992" y="37.500023" zOrder="2">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="input_pseudo" width="0.000000" x="35.999992" y="150.499985" zOrder="3">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="true" height="43.000000" layer="" locked="false" name="btn" width="169.000000" x="31.000011" y="148.500000" zOrder="1">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables>
                        <variable name="type" value="input_pseudo" />
                    </initialVariables>
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="output_server" width="0.000000" x="32.999992" y="224.500000" zOrder="4">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="DEBUG" width="0.000000" x="222.000000" y="328.500000" zOrder="1">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="true" height="314.000000" layer="" locked="false" name="btn" width="816.000000" x="-10.000000" y="290.500000" zOrder="0">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
                <instance angle="0.000000" customSize="false" height="0.000000" layer="" locked="false" name="switch_scene" width="0.000000" x="753.000000" y="15.500023" zOrder="5">
                    <numberProperties />
                    <stringProperties />
                    <initialVariables />
                </instance>
            </instances>
            <objects>
                <object name="btn" type="Sprite">
                    <variables />
                    <behaviors />
                    <animations>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="normal.jpg">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="25.000000" y="25.000000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="50.000000" />
                                                    <vertice x="0.000000" y="50.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="select.jpg">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="25.000000" y="25.000000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="0.000000" />
                                                    <vertice x="50.000000" y="50.000000" />
                                                    <vertice x="0.000000" y="50.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                    </animations>
                </object>
                <object bold="false" italic="false" name="text_1" smoothed="true" type="TextObject::Text" underlined="false">
                    <variables />
                    <behaviors />
                    <string>data to server</string>
                    <font></font>
                    <characterSize>20</characterSize>
                    <color b="255" g="255" r="255" />
                </object>
                <object name="input_pseudo" type="TextEntryObject::TextEntry">
                    <variables />
                    <behaviors />
                </object>
                <object height="32.000000" name="normal_BTN" texture="normal.jpg" type="TiledSpriteObject::TiledSprite" width="32.000000">
                    <variables />
                    <behaviors />
                </object>
                <object bold="false" italic="false" name="output_server" smoothed="true" type="TextObject::Text" underlined="false">
                    <variables />
                    <behaviors />
                    <string>none</string>
                    <font></font>
                    <characterSize>20</characterSize>
                    <color b="0" g="0" r="0" />
                </object>
                <object name="Joueur" type="Sprite">
                    <variables />
                    <behaviors />
                    <animations>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="Character Boy.png">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="50.500000" y="85.500000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="101.000000" y="0.000000" />
                                                    <vertice x="101.000000" y="171.000000" />
                                                    <vertice x="0.000000" y="171.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="Character Cat Girl.png">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="50.500000" y="85.500000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="101.000000" y="0.000000" />
                                                    <vertice x="101.000000" y="171.000000" />
                                                    <vertice x="0.000000" y="171.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="Character Horn Girl.png">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="50.500000" y="85.500000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="101.000000" y="0.000000" />
                                                    <vertice x="101.000000" y="171.000000" />
                                                    <vertice x="0.000000" y="171.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                    </animations>
                </object>
                <object bold="false" italic="false" name="DEBUG" smoothed="true" type="TextObject::Text" underlined="false">
                    <variables />
                    <behaviors />
                    <string>Text</string>
                    <font></font>
                    <characterSize>20</characterSize>
                    <color b="255" g="255" r="255" />
                </object>
                <object name="switch_scene" type="Sprite">
                    <variables />
                    <behaviors />
                    <animations>
                        <animation name="" useMultipleDirections="false">
                            <directions>
                                <direction looping="false" timeBetweenFrames="1.000000">
                                    <sprites>
                                        <sprite hasCustomCollisionMask="false" image="XMLID_44_.png">
                                            <points />
                                            <originPoint name="origine" x="0.000000" y="0.000000" />
                                            <centerPoint automatic="true" name="centre" x="18.000000" y="20.000000" />
                                            <customCollisionMask>
                                                <polygon>
                                                    <vertice x="0.000000" y="0.000000" />
                                                    <vertice x="36.000000" y="0.000000" />
                                                    <vertice x="36.000000" y="40.000000" />
                                                    <vertice x="0.000000" y="40.000000" />
                                                </polygon>
                                            </customCollisionMask>
                                        </sprite>
                                    </sprites>
                                </direction>
                            </directions>
                        </animation>
                    </animations>
                </object>
            </objects>
            <events>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="SourisSurObjet" />
                            <parameters>
                                <parameter>switch_scene</parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="Scene" />
                            <parameters>
                                <parameter></parameter>
                                <parameter>&quot;creation_joueur&quot;</parameter>
                                <parameter>true</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Link</type>
                    <include end="-1" includeAll="true" start="-1" />
                    <target>Evenements externes</target>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="0" g="255" r="255" textB="0" textG="0" textR="0" />
                    <comment>Importations</comment>
                    <comment2>Import</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment></comment>
                    <comment2>Librairies</comment2>
                </event>
                <event disabled="true" folded="true">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="DepartScene" />
                            <parameters>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.io = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &apos;&quot;+o+&quot;&apos;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var url = _dereq_(&apos;./url&apos;);&#x0D;&#x0A;var parser = _dereq_(&apos;socket.io-parser&apos;);&#x0D;&#x0A;var Manager = _dereq_(&apos;./manager&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = exports = lookup;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Managers cache.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var cache = exports.managers = {};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Looks up an existing `Manager` for multiplexing.&#x0D;&#x0A; * If the user summons:&#x0D;&#x0A; *&#x0D;&#x0A; * `io(&apos;http://localhost/a&apos;);`&#x0D;&#x0A; * `io(&apos;http://localhost/b&apos;);`&#x0D;&#x0A; *&#x0D;&#x0A; * We reuse the existing instance based on same scheme/port/host,&#x0D;&#x0A; * and we initialize sockets for each namespace.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function lookup(uri, opts) {&#x0D;&#x0A; if (typeof uri == &apos;object&apos;) {&#x0D;&#x0A; opts = uri;&#x0D;&#x0A; uri = undefined;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; opts = opts || {};&#x0D;&#x0A;&#x0D;&#x0A; var parsed = url(uri);&#x0D;&#x0A; var source = parsed.source;&#x0D;&#x0A; var id = parsed.id;&#x0D;&#x0A; var path = parsed.path;&#x0D;&#x0A; var sameNamespace = cache[id] &amp;&amp; path in cache[id].nsps;&#x0D;&#x0A; var newConnection = opts.forceNew || opts[&apos;force new connection&apos;] ||&#x0D;&#x0A; false === opts.multiplex || sameNamespace;&#x0D;&#x0A;&#x0D;&#x0A; var io;&#x0D;&#x0A;&#x0D;&#x0A; if (newConnection) {&#x0D;&#x0A; debug(&apos;ignoring socket cache for %s&apos;, source);&#x0D;&#x0A; io = Manager(source, opts);&#x0D;&#x0A; } else {&#x0D;&#x0A; if (!cache[id]) {&#x0D;&#x0A; debug(&apos;new io instance for %s&apos;, source);&#x0D;&#x0A; cache[id] = Manager(source, opts);&#x0D;&#x0A; }&#x0D;&#x0A; io = cache[id];&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return io.socket(parsed.path);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Protocol version.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.protocol = parser.protocol;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * `connect`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} uri&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.connect = lookup;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Expose constructors for standalone build.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.Manager = _dereq_(&apos;./manager&apos;);&#x0D;&#x0A;exports.Socket = _dereq_(&apos;./socket&apos;);&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;./manager&quot;:2,&quot;./socket&quot;:4,&quot;./url&quot;:5,&quot;debug&quot;:14,&quot;socket.io-parser&quot;:40}],2:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var eio = _dereq_(&apos;engine.io-client&apos;);&#x0D;&#x0A;var Socket = _dereq_(&apos;./socket&apos;);&#x0D;&#x0A;var Emitter = _dereq_(&apos;component-emitter&apos;);&#x0D;&#x0A;var parser = _dereq_(&apos;socket.io-parser&apos;);&#x0D;&#x0A;var on = _dereq_(&apos;./on&apos;);&#x0D;&#x0A;var bind = _dereq_(&apos;component-bind&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:manager&apos;);&#x0D;&#x0A;var indexOf = _dereq_(&apos;indexof&apos;);&#x0D;&#x0A;var Backoff = _dereq_(&apos;backo2&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * IE6+ hasOwnProperty&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var has = Object.prototype.hasOwnProperty;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Manager;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * `Manager` constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} engine instance or engine uri/opts&#x0D;&#x0A; * @param {Object} options&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Manager(uri, opts){&#x0D;&#x0A; if (!(this instanceof Manager)) return new Manager(uri, opts);&#x0D;&#x0A; if (uri &amp;&amp; (&apos;object&apos; == typeof uri)) {&#x0D;&#x0A; opts = uri;&#x0D;&#x0A; uri = undefined;&#x0D;&#x0A; }&#x0D;&#x0A; opts = opts || {};&#x0D;&#x0A;&#x0D;&#x0A; opts.path = opts.path || &apos;/socket.io&apos;;&#x0D;&#x0A; this.nsps = {};&#x0D;&#x0A; this.subs = [];&#x0D;&#x0A; this.opts = opts;&#x0D;&#x0A; this.reconnection(opts.reconnection !== false);&#x0D;&#x0A; this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);&#x0D;&#x0A; this.reconnectionDelay(opts.reconnectionDelay || 1000);&#x0D;&#x0A; this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);&#x0D;&#x0A; this.randomizationFactor(opts.randomizationFactor || 0.5);&#x0D;&#x0A; this.backoff = new Backoff({&#x0D;&#x0A; min: this.reconnectionDelay(),&#x0D;&#x0A; max: this.reconnectionDelayMax(),&#x0D;&#x0A; jitter: this.randomizationFactor()&#x0D;&#x0A; });&#x0D;&#x0A; this.timeout(null == opts.timeout ? 20000 : opts.timeout);&#x0D;&#x0A; this.readyState = &apos;closed&apos;;&#x0D;&#x0A; this.uri = uri;&#x0D;&#x0A; this.connecting = [];&#x0D;&#x0A; this.lastPing = null;&#x0D;&#x0A; this.encoding = false;&#x0D;&#x0A; this.packetBuffer = [];&#x0D;&#x0A; this.encoder = new parser.Encoder();&#x0D;&#x0A; this.decoder = new parser.Decoder();&#x0D;&#x0A; this.autoConnect = opts.autoConnect !== false;&#x0D;&#x0A; if (this.autoConnect) this.open();&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Propagate given event to sockets and emit on `this`&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.emitAll = function() {&#x0D;&#x0A; this.emit.apply(this, arguments);&#x0D;&#x0A; for (var nsp in this.nsps) {&#x0D;&#x0A; if (has.call(this.nsps, nsp)) {&#x0D;&#x0A; this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Update `socket.id` of all sockets&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.updateSocketIds = function(){&#x0D;&#x0A; for (var nsp in this.nsps) {&#x0D;&#x0A; if (has.call(this.nsps, nsp)) {&#x0D;&#x0A; this.nsps[nsp].id = this.engine.id;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mix in `Emitter`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter(Manager.prototype);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the `reconnection` config.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Boolean} true/false if it should automatically reconnect&#x0D;&#x0A; * @return {Manager} self or value&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.reconnection = function(v){&#x0D;&#x0A; if (!arguments.length) return this._reconnection;&#x0D;&#x0A; this._reconnection = !!v;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the reconnection attempts config.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Number} max reconnection attempts before giving up&#x0D;&#x0A; * @return {Manager} self or value&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.reconnectionAttempts = function(v){&#x0D;&#x0A; if (!arguments.length) return this._reconnectionAttempts;&#x0D;&#x0A; this._reconnectionAttempts = v;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the delay between reconnections.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Number} delay&#x0D;&#x0A; * @return {Manager} self or value&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.reconnectionDelay = function(v){&#x0D;&#x0A; if (!arguments.length) return this._reconnectionDelay;&#x0D;&#x0A; this._reconnectionDelay = v;&#x0D;&#x0A; this.backoff &amp;&amp; this.backoff.setMin(v);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.randomizationFactor = function(v){&#x0D;&#x0A; if (!arguments.length) return this._randomizationFactor;&#x0D;&#x0A; this._randomizationFactor = v;&#x0D;&#x0A; this.backoff &amp;&amp; this.backoff.setJitter(v);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the maximum delay between reconnections.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Number} delay&#x0D;&#x0A; * @return {Manager} self or value&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.reconnectionDelayMax = function(v){&#x0D;&#x0A; if (!arguments.length) return this._reconnectionDelayMax;&#x0D;&#x0A; this._reconnectionDelayMax = v;&#x0D;&#x0A; this.backoff &amp;&amp; this.backoff.setMax(v);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the connection timeout. `false` to disable&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Manager} self or value&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.timeout = function(v){&#x0D;&#x0A; if (!arguments.length) return this._timeout;&#x0D;&#x0A; this._timeout = v;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Starts trying to reconnect if reconnection is enabled and we have not&#x0D;&#x0A; * started reconnecting yet&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.maybeReconnectOnOpen = function() {&#x0D;&#x0A; // Only try to reconnect if it&apos;s the first time we&apos;re connecting&#x0D;&#x0A; if (!this.reconnecting &amp;&amp; this._reconnection &amp;&amp; this.backoff.attempts === 0) {&#x0D;&#x0A; // keeps reconnection from firing twice for the same reconnection loop&#x0D;&#x0A; this.reconnect();&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the current transport `socket`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Function} optional, callback&#x0D;&#x0A; * @return {Manager} self&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.open =&#x0D;&#x0A;Manager.prototype.connect = function(fn){&#x0D;&#x0A; debug(&apos;readyState %s&apos;, this.readyState);&#x0D;&#x0A; if (~this.readyState.indexOf(&apos;open&apos;)) return this;&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;opening %s&apos;, this.uri);&#x0D;&#x0A; this.engine = eio(this.uri, this.opts);&#x0D;&#x0A; var socket = this.engine;&#x0D;&#x0A; var self = this;&#x0D;&#x0A; this.readyState = &apos;opening&apos;;&#x0D;&#x0A; this.skipReconnect = false;&#x0D;&#x0A;&#x0D;&#x0A; // emit `open`&#x0D;&#x0A; var openSub = on(socket, &apos;open&apos;, function() {&#x0D;&#x0A; self.onopen();&#x0D;&#x0A; fn &amp;&amp; fn();&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; // emit `connect_error`&#x0D;&#x0A; var errorSub = on(socket, &apos;error&apos;, function(data){&#x0D;&#x0A; debug(&apos;connect_error&apos;);&#x0D;&#x0A; self.cleanup();&#x0D;&#x0A; self.readyState = &apos;closed&apos;;&#x0D;&#x0A; self.emitAll(&apos;connect_error&apos;, data);&#x0D;&#x0A; if (fn) {&#x0D;&#x0A; var err = new Error(&apos;Connection error&apos;);&#x0D;&#x0A; err.data = data;&#x0D;&#x0A; fn(err);&#x0D;&#x0A; } else {&#x0D;&#x0A; // Only do this if there is no fn to handle the error&#x0D;&#x0A; self.maybeReconnectOnOpen();&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; // emit `connect_timeout`&#x0D;&#x0A; if (false !== this._timeout) {&#x0D;&#x0A; var timeout = this._timeout;&#x0D;&#x0A; debug(&apos;connect attempt will timeout after %d&apos;, timeout);&#x0D;&#x0A;&#x0D;&#x0A; // set timer&#x0D;&#x0A; var timer = setTimeout(function(){&#x0D;&#x0A; debug(&apos;connect attempt timed out after %d&apos;, timeout);&#x0D;&#x0A; openSub.destroy();&#x0D;&#x0A; socket.close();&#x0D;&#x0A; socket.emit(&apos;error&apos;, &apos;timeout&apos;);&#x0D;&#x0A; self.emitAll(&apos;connect_timeout&apos;, timeout);&#x0D;&#x0A; }, timeout);&#x0D;&#x0A;&#x0D;&#x0A; this.subs.push({&#x0D;&#x0A; destroy: function(){&#x0D;&#x0A; clearTimeout(timer);&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.subs.push(openSub);&#x0D;&#x0A; this.subs.push(errorSub);&#x0D;&#x0A;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon transport open.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.onopen = function(){&#x0D;&#x0A; debug(&apos;open&apos;);&#x0D;&#x0A;&#x0D;&#x0A; // clear old subs&#x0D;&#x0A; this.cleanup();&#x0D;&#x0A;&#x0D;&#x0A; // mark as open&#x0D;&#x0A; this.readyState = &apos;open&apos;;&#x0D;&#x0A; this.emit(&apos;open&apos;);&#x0D;&#x0A;&#x0D;&#x0A; // add new subs&#x0D;&#x0A; var socket = this.engine;&#x0D;&#x0A; this.subs.push(on(socket, &apos;data&apos;, bind(this, &apos;ondata&apos;)));&#x0D;&#x0A; this.subs.push(on(socket, &apos;ping&apos;, bind(this, &apos;onping&apos;)));&#x0D;&#x0A; this.subs.push(on(socket, &apos;pong&apos;, bind(this, &apos;onpong&apos;)));&#x0D;&#x0A; this.subs.push(on(socket, &apos;error&apos;, bind(this, &apos;onerror&apos;)));&#x0D;&#x0A; this.subs.push(on(socket, &apos;close&apos;, bind(this, &apos;onclose&apos;)));&#x0D;&#x0A; this.subs.push(on(this.decoder, &apos;decoded&apos;, bind(this, &apos;ondecoded&apos;)));&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon a ping.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.onping = function(){&#x0D;&#x0A; this.lastPing = new Date;&#x0D;&#x0A; this.emitAll(&apos;ping&apos;);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon a packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.onpong = function(){&#x0D;&#x0A; this.emitAll(&apos;pong&apos;, new Date - this.lastPing);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called with data.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.ondata = function(data){&#x0D;&#x0A; this.decoder.add(data);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called when parser fully decodes a packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.ondecoded = function(packet) {&#x0D;&#x0A; this.emit(&apos;packet&apos;, packet);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon socket error.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.onerror = function(err){&#x0D;&#x0A; debug(&apos;error&apos;, err);&#x0D;&#x0A; this.emitAll(&apos;error&apos;, err);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Creates a new socket for the given `nsp`.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Socket}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.socket = function(nsp){&#x0D;&#x0A; var socket = this.nsps[nsp];&#x0D;&#x0A; if (!socket) {&#x0D;&#x0A; socket = new Socket(this, nsp);&#x0D;&#x0A; this.nsps[nsp] = socket;&#x0D;&#x0A; var self = this;&#x0D;&#x0A; socket.on(&apos;connecting&apos;, onConnecting);&#x0D;&#x0A; socket.on(&apos;connect&apos;, function(){&#x0D;&#x0A; socket.id = self.engine.id;&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; if (this.autoConnect) {&#x0D;&#x0A; // manually call here since connecting evnet is fired before listening&#x0D;&#x0A; onConnecting();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function onConnecting() {&#x0D;&#x0A; if (!~indexOf(self.connecting, socket)) {&#x0D;&#x0A; self.connecting.push(socket);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return socket;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon a socket close.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Socket} socket&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.destroy = function(socket){&#x0D;&#x0A; var index = indexOf(this.connecting, socket);&#x0D;&#x0A; if (~index) this.connecting.splice(index, 1);&#x0D;&#x0A; if (this.connecting.length) return;&#x0D;&#x0A;&#x0D;&#x0A; this.close();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Writes a packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.packet = function(packet){&#x0D;&#x0A; debug(&apos;writing packet %j&apos;, packet);&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; if (!self.encoding) {&#x0D;&#x0A; // encode, then write to engine with result&#x0D;&#x0A; self.encoding = true;&#x0D;&#x0A; this.encoder.encode(packet, function(encodedPackets) {&#x0D;&#x0A; for (var i = 0; i &lt; encodedPackets.length; i++) {&#x0D;&#x0A; self.engine.write(encodedPackets[i], packet.options);&#x0D;&#x0A; }&#x0D;&#x0A; self.encoding = false;&#x0D;&#x0A; self.processPacketQueue();&#x0D;&#x0A; });&#x0D;&#x0A; } else { // add packet to the queue&#x0D;&#x0A; self.packetBuffer.push(packet);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * If packet buffer is non-empty, begins encoding the&#x0D;&#x0A; * next packet in line.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.processPacketQueue = function() {&#x0D;&#x0A; if (this.packetBuffer.length &gt; 0 &amp;&amp; !this.encoding) {&#x0D;&#x0A; var pack = this.packetBuffer.shift();&#x0D;&#x0A; this.packet(pack);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Clean up transport subscriptions and packet buffer.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.cleanup = function(){&#x0D;&#x0A; debug(&apos;cleanup&apos;);&#x0D;&#x0A;&#x0D;&#x0A; var sub;&#x0D;&#x0A; while (sub = this.subs.shift()) sub.destroy();&#x0D;&#x0A;&#x0D;&#x0A; this.packetBuffer = [];&#x0D;&#x0A; this.encoding = false;&#x0D;&#x0A; this.lastPing = null;&#x0D;&#x0A;&#x0D;&#x0A; this.decoder.destroy();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Close the current socket.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.close =&#x0D;&#x0A;Manager.prototype.disconnect = function(){&#x0D;&#x0A; debug(&apos;disconnect&apos;);&#x0D;&#x0A; this.skipReconnect = true;&#x0D;&#x0A; this.reconnecting = false;&#x0D;&#x0A; if (&apos;opening&apos; == this.readyState) {&#x0D;&#x0A; // `onclose` will not fire because&#x0D;&#x0A; // an open event never happened&#x0D;&#x0A; this.cleanup();&#x0D;&#x0A; }&#x0D;&#x0A; this.backoff.reset();&#x0D;&#x0A; this.readyState = &apos;closed&apos;;&#x0D;&#x0A; if (this.engine) this.engine.close();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon engine close.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.onclose = function(reason){&#x0D;&#x0A; debug(&apos;onclose&apos;);&#x0D;&#x0A;&#x0D;&#x0A; this.cleanup();&#x0D;&#x0A; this.backoff.reset();&#x0D;&#x0A; this.readyState = &apos;closed&apos;;&#x0D;&#x0A; this.emit(&apos;close&apos;, reason);&#x0D;&#x0A;&#x0D;&#x0A; if (this._reconnection &amp;&amp; !this.skipReconnect) {&#x0D;&#x0A; this.reconnect();&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Attempt a reconnection.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.reconnect = function(){&#x0D;&#x0A; if (this.reconnecting || this.skipReconnect) return this;&#x0D;&#x0A;&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; if (this.backoff.attempts &gt;= this._reconnectionAttempts) {&#x0D;&#x0A; debug(&apos;reconnect failed&apos;);&#x0D;&#x0A; this.backoff.reset();&#x0D;&#x0A; this.emitAll(&apos;reconnect_failed&apos;);&#x0D;&#x0A; this.reconnecting = false;&#x0D;&#x0A; } else {&#x0D;&#x0A; var delay = this.backoff.duration();&#x0D;&#x0A; debug(&apos;will wait %dms before reconnect attempt&apos;, delay);&#x0D;&#x0A;&#x0D;&#x0A; this.reconnecting = true;&#x0D;&#x0A; var timer = setTimeout(function(){&#x0D;&#x0A; if (self.skipReconnect) return;&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;attempting reconnect&apos;);&#x0D;&#x0A; self.emitAll(&apos;reconnect_attempt&apos;, self.backoff.attempts);&#x0D;&#x0A; self.emitAll(&apos;reconnecting&apos;, self.backoff.attempts);&#x0D;&#x0A;&#x0D;&#x0A; // check again for the case socket closed in above events&#x0D;&#x0A; if (self.skipReconnect) return;&#x0D;&#x0A;&#x0D;&#x0A; self.open(function(err){&#x0D;&#x0A; if (err) {&#x0D;&#x0A; debug(&apos;reconnect attempt error&apos;);&#x0D;&#x0A; self.reconnecting = false;&#x0D;&#x0A; self.reconnect();&#x0D;&#x0A; self.emitAll(&apos;reconnect_error&apos;, err.data);&#x0D;&#x0A; } else {&#x0D;&#x0A; debug(&apos;reconnect success&apos;);&#x0D;&#x0A; self.onreconnect();&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A; }, delay);&#x0D;&#x0A;&#x0D;&#x0A; this.subs.push({&#x0D;&#x0A; destroy: function(){&#x0D;&#x0A; clearTimeout(timer);&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon successful reconnect.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Manager.prototype.onreconnect = function(){&#x0D;&#x0A; var attempt = this.backoff.attempts;&#x0D;&#x0A; this.reconnecting = false;&#x0D;&#x0A; this.backoff.reset();&#x0D;&#x0A; this.updateSocketIds();&#x0D;&#x0A; this.emitAll(&apos;reconnect&apos;, attempt);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;./on&quot;:3,&quot;./socket&quot;:4,&quot;backo2&quot;:8,&quot;component-bind&quot;:11,&quot;component-emitter&quot;:12,&quot;debug&quot;:14,&quot;engine.io-client&quot;:16,&quot;indexof&quot;:32,&quot;socket.io-parser&quot;:40}],3:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = on;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Helper for subscriptions.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`&#x0D;&#x0A; * @param {String} event name&#x0D;&#x0A; * @param {Function} callback&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function on(obj, ev, fn) {&#x0D;&#x0A; obj.on(ev, fn);&#x0D;&#x0A; return {&#x0D;&#x0A; destroy: function(){&#x0D;&#x0A; obj.removeListener(ev, fn);&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{}],4:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var parser = _dereq_(&apos;socket.io-parser&apos;);&#x0D;&#x0A;var Emitter = _dereq_(&apos;component-emitter&apos;);&#x0D;&#x0A;var toArray = _dereq_(&apos;to-array&apos;);&#x0D;&#x0A;var on = _dereq_(&apos;./on&apos;);&#x0D;&#x0A;var bind = _dereq_(&apos;component-bind&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:socket&apos;);&#x0D;&#x0A;var hasBin = _dereq_(&apos;has-binary&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = exports = Socket;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Internal events (blacklisted).&#x0D;&#x0A; * These events can&apos;t be emitted by the user.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var events = {&#x0D;&#x0A; connect: 1,&#x0D;&#x0A; connect_error: 1,&#x0D;&#x0A; connect_timeout: 1,&#x0D;&#x0A; connecting: 1,&#x0D;&#x0A; disconnect: 1,&#x0D;&#x0A; error: 1,&#x0D;&#x0A; reconnect: 1,&#x0D;&#x0A; reconnect_attempt: 1,&#x0D;&#x0A; reconnect_failed: 1,&#x0D;&#x0A; reconnect_error: 1,&#x0D;&#x0A; reconnecting: 1,&#x0D;&#x0A; ping: 1,&#x0D;&#x0A; pong: 1&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Shortcut to `Emitter#emit`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var emit = Emitter.prototype.emit;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * `Socket` constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Socket(io, nsp){&#x0D;&#x0A; this.io = io;&#x0D;&#x0A; this.nsp = nsp;&#x0D;&#x0A; this.json = this; // compat&#x0D;&#x0A; this.ids = 0;&#x0D;&#x0A; this.acks = {};&#x0D;&#x0A; this.receiveBuffer = [];&#x0D;&#x0A; this.sendBuffer = [];&#x0D;&#x0A; this.connected = false;&#x0D;&#x0A; this.disconnected = true;&#x0D;&#x0A; if (this.io.autoConnect) this.open();&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mix in `Emitter`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter(Socket.prototype);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Subscribe to open, close and packet events&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.subEvents = function() {&#x0D;&#x0A; if (this.subs) return;&#x0D;&#x0A;&#x0D;&#x0A; var io = this.io;&#x0D;&#x0A; this.subs = [&#x0D;&#x0A; on(io, &apos;open&apos;, bind(this, &apos;onopen&apos;)),&#x0D;&#x0A; on(io, &apos;packet&apos;, bind(this, &apos;onpacket&apos;)),&#x0D;&#x0A; on(io, &apos;close&apos;, bind(this, &apos;onclose&apos;))&#x0D;&#x0A; ];&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * &quot;Opens&quot; the socket.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.open =&#x0D;&#x0A;Socket.prototype.connect = function(){&#x0D;&#x0A; if (this.connected) return this;&#x0D;&#x0A;&#x0D;&#x0A; this.subEvents();&#x0D;&#x0A; this.io.open(); // ensure open&#x0D;&#x0A; if (&apos;open&apos; == this.io.readyState) this.onopen();&#x0D;&#x0A; this.emit(&apos;connecting&apos;);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sends a `message` event.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Socket} self&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.send = function(){&#x0D;&#x0A; var args = toArray(arguments);&#x0D;&#x0A; args.unshift(&apos;message&apos;);&#x0D;&#x0A; this.emit.apply(this, args);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Override `emit`.&#x0D;&#x0A; * If the event is in `events`, it&apos;s emitted normally.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event name&#x0D;&#x0A; * @return {Socket} self&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.emit = function(ev){&#x0D;&#x0A; if (events.hasOwnProperty(ev)) {&#x0D;&#x0A; emit.apply(this, arguments);&#x0D;&#x0A; return this;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var args = toArray(arguments);&#x0D;&#x0A; var parserType = parser.EVENT; // default&#x0D;&#x0A; if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary&#x0D;&#x0A; var packet = { type: parserType, data: args };&#x0D;&#x0A;&#x0D;&#x0A; packet.options = {};&#x0D;&#x0A; packet.options.compress = !this.flags || false !== this.flags.compress;&#x0D;&#x0A;&#x0D;&#x0A; // event ack callback&#x0D;&#x0A; if (&apos;function&apos; == typeof args[args.length - 1]) {&#x0D;&#x0A; debug(&apos;emitting packet with ack id %d&apos;, this.ids);&#x0D;&#x0A; this.acks[this.ids] = args.pop();&#x0D;&#x0A; packet.id = this.ids++;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (this.connected) {&#x0D;&#x0A; this.packet(packet);&#x0D;&#x0A; } else {&#x0D;&#x0A; this.sendBuffer.push(packet);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; delete this.flags;&#x0D;&#x0A;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sends a packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.packet = function(packet){&#x0D;&#x0A; packet.nsp = this.nsp;&#x0D;&#x0A; this.io.packet(packet);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon engine `open`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onopen = function(){&#x0D;&#x0A; debug(&apos;transport is open - connecting&apos;);&#x0D;&#x0A;&#x0D;&#x0A; // write connect packet if necessary&#x0D;&#x0A; if (&apos;/&apos; != this.nsp) {&#x0D;&#x0A; this.packet({ type: parser.CONNECT });&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon engine `close`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} reason&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onclose = function(reason){&#x0D;&#x0A; debug(&apos;close (%s)&apos;, reason);&#x0D;&#x0A; this.connected = false;&#x0D;&#x0A; this.disconnected = true;&#x0D;&#x0A; delete this.id;&#x0D;&#x0A; this.emit(&apos;disconnect&apos;, reason);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called with socket packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onpacket = function(packet){&#x0D;&#x0A; if (packet.nsp != this.nsp) return;&#x0D;&#x0A;&#x0D;&#x0A; switch (packet.type) {&#x0D;&#x0A; case parser.CONNECT:&#x0D;&#x0A; this.onconnect();&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case parser.EVENT:&#x0D;&#x0A; this.onevent(packet);&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case parser.BINARY_EVENT:&#x0D;&#x0A; this.onevent(packet);&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case parser.ACK:&#x0D;&#x0A; this.onack(packet);&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case parser.BINARY_ACK:&#x0D;&#x0A; this.onack(packet);&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case parser.DISCONNECT:&#x0D;&#x0A; this.ondisconnect();&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case parser.ERROR:&#x0D;&#x0A; this.emit(&apos;error&apos;, packet.data);&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon a server event.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onevent = function(packet){&#x0D;&#x0A; var args = packet.data || [];&#x0D;&#x0A; debug(&apos;emitting event %j&apos;, args);&#x0D;&#x0A;&#x0D;&#x0A; if (null != packet.id) {&#x0D;&#x0A; debug(&apos;attaching ack callback to event&apos;);&#x0D;&#x0A; args.push(this.ack(packet.id));&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (this.connected) {&#x0D;&#x0A; emit.apply(this, args);&#x0D;&#x0A; } else {&#x0D;&#x0A; this.receiveBuffer.push(args);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Produces an ack callback to emit with an event.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.ack = function(id){&#x0D;&#x0A; var self = this;&#x0D;&#x0A; var sent = false;&#x0D;&#x0A; return function(){&#x0D;&#x0A; // prevent double callbacks&#x0D;&#x0A; if (sent) return;&#x0D;&#x0A; sent = true;&#x0D;&#x0A; var args = toArray(arguments);&#x0D;&#x0A; debug(&apos;sending ack %j&apos;, args);&#x0D;&#x0A;&#x0D;&#x0A; var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;&#x0D;&#x0A; self.packet({&#x0D;&#x0A; type: type,&#x0D;&#x0A; id: id,&#x0D;&#x0A; data: args&#x0D;&#x0A; });&#x0D;&#x0A; };&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon a server acknowlegement.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onack = function(packet){&#x0D;&#x0A; var ack = this.acks[packet.id];&#x0D;&#x0A; if (&apos;function&apos; == typeof ack) {&#x0D;&#x0A; debug(&apos;calling ack %s with %j&apos;, packet.id, packet.data);&#x0D;&#x0A; ack.apply(this, packet.data);&#x0D;&#x0A; delete this.acks[packet.id];&#x0D;&#x0A; } else {&#x0D;&#x0A; debug(&apos;bad ack %s&apos;, packet.id);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon server connect.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onconnect = function(){&#x0D;&#x0A; this.connected = true;&#x0D;&#x0A; this.disconnected = false;&#x0D;&#x0A; this.emit(&apos;connect&apos;);&#x0D;&#x0A; this.emitBuffered();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Emit buffered events (received and emitted).&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.emitBuffered = function(){&#x0D;&#x0A; var i;&#x0D;&#x0A; for (i = 0; i &lt; this.receiveBuffer.length; i++) {&#x0D;&#x0A; emit.apply(this, this.receiveBuffer[i]);&#x0D;&#x0A; }&#x0D;&#x0A; this.receiveBuffer = [];&#x0D;&#x0A;&#x0D;&#x0A; for (i = 0; i &lt; this.sendBuffer.length; i++) {&#x0D;&#x0A; this.packet(this.sendBuffer[i]);&#x0D;&#x0A; }&#x0D;&#x0A; this.sendBuffer = [];&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon server disconnect.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.ondisconnect = function(){&#x0D;&#x0A; debug(&apos;server disconnect (%s)&apos;, this.nsp);&#x0D;&#x0A; this.destroy();&#x0D;&#x0A; this.onclose(&apos;io server disconnect&apos;);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon forced client/server side disconnections,&#x0D;&#x0A; * this method ensures the manager stops tracking us and&#x0D;&#x0A; * that reconnections don&apos;t get triggered for this.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.destroy = function(){&#x0D;&#x0A; if (this.subs) {&#x0D;&#x0A; // clean subscriptions to avoid reconnections&#x0D;&#x0A; for (var i = 0; i &lt; this.subs.length; i++) {&#x0D;&#x0A; this.subs[i].destroy();&#x0D;&#x0A; }&#x0D;&#x0A; this.subs = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.io.destroy(this);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Disconnects the socket manually.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Socket} self&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.close =&#x0D;&#x0A;Socket.prototype.disconnect = function(){&#x0D;&#x0A; if (this.connected) {&#x0D;&#x0A; debug(&apos;performing disconnect (%s)&apos;, this.nsp);&#x0D;&#x0A; this.packet({ type: parser.DISCONNECT });&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // remove socket from pool&#x0D;&#x0A; this.destroy();&#x0D;&#x0A;&#x0D;&#x0A; if (this.connected) {&#x0D;&#x0A; // fire events&#x0D;&#x0A; this.onclose(&apos;io client disconnect&apos;);&#x0D;&#x0A; }&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the compress flag.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Boolean} if `true`, compresses the sending data&#x0D;&#x0A; * @return {Socket} self&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.compress = function(compress){&#x0D;&#x0A; this.flags = this.flags || {};&#x0D;&#x0A; this.flags.compress = compress;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;./on&quot;:3,&quot;component-bind&quot;:11,&quot;component-emitter&quot;:12,&quot;debug&quot;:14,&quot;has-binary&quot;:30,&quot;socket.io-parser&quot;:40,&quot;to-array&quot;:43}],5:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var parseuri = _dereq_(&apos;parseuri&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-client:url&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = url;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * URL parser.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} url&#x0D;&#x0A; * @param {Object} An object meant to mimic window.location.&#x0D;&#x0A; * Defaults to window.location.&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function url(uri, loc){&#x0D;&#x0A; var obj = uri;&#x0D;&#x0A;&#x0D;&#x0A; // default to window.location&#x0D;&#x0A; var loc = loc || global.location;&#x0D;&#x0A; if (null == uri) uri = loc.protocol + &apos;//&apos; + loc.host;&#x0D;&#x0A;&#x0D;&#x0A; // relative path support&#x0D;&#x0A; if (&apos;string&apos; == typeof uri) {&#x0D;&#x0A; if (&apos;/&apos; == uri.charAt(0)) {&#x0D;&#x0A; if (&apos;/&apos; == uri.charAt(1)) {&#x0D;&#x0A; uri = loc.protocol + uri;&#x0D;&#x0A; } else {&#x0D;&#x0A; uri = loc.host + uri;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (!/^(https?|wss?):\/\//.test(uri)) {&#x0D;&#x0A; debug(&apos;protocol-less url %s&apos;, uri);&#x0D;&#x0A; if (&apos;undefined&apos; != typeof loc) {&#x0D;&#x0A; uri = loc.protocol + &apos;//&apos; + uri;&#x0D;&#x0A; } else {&#x0D;&#x0A; uri = &apos;https://&apos; + uri;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // parse&#x0D;&#x0A; debug(&apos;parse %s&apos;, uri);&#x0D;&#x0A; obj = parseuri(uri);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // make sure we treat `localhost:80` and `localhost` equally&#x0D;&#x0A; if (!obj.port) {&#x0D;&#x0A; if (/^(http|ws)$/.test(obj.protocol)) {&#x0D;&#x0A; obj.port = &apos;80&apos;;&#x0D;&#x0A; }&#x0D;&#x0A; else if (/^(http|ws)s$/.test(obj.protocol)) {&#x0D;&#x0A; obj.port = &apos;443&apos;;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; obj.path = obj.path || &apos;/&apos;;&#x0D;&#x0A;&#x0D;&#x0A; var ipv6 = obj.host.indexOf(&apos;:&apos;) !== -1;&#x0D;&#x0A; var host = ipv6 ? &apos;[&apos; + obj.host + &apos;]&apos; : obj.host;&#x0D;&#x0A;&#x0D;&#x0A; // define unique id&#x0D;&#x0A; obj.id = obj.protocol + &apos;://&apos; + host + &apos;:&apos; + obj.port;&#x0D;&#x0A; // define href&#x0D;&#x0A; obj.href = obj.protocol + &apos;://&apos; + host + (loc &amp;&amp; loc.port == obj.port ? &apos;&apos; : (&apos;:&apos; + obj.port));&#x0D;&#x0A;&#x0D;&#x0A; return obj;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;debug&quot;:14,&quot;parseuri&quot;:38}],6:[function(_dereq_,module,exports){&#x0D;&#x0A;module.exports = after&#x0D;&#x0A;&#x0D;&#x0A;function after(count, callback, err_cb) {&#x0D;&#x0A; var bail = false&#x0D;&#x0A; err_cb = err_cb || noop&#x0D;&#x0A; proxy.count = count&#x0D;&#x0A;&#x0D;&#x0A; return (count === 0) ? callback() : proxy&#x0D;&#x0A;&#x0D;&#x0A; function proxy(err, result) {&#x0D;&#x0A; if (proxy.count &lt;= 0) {&#x0D;&#x0A; throw new Error(&apos;after called too many times&apos;)&#x0D;&#x0A; }&#x0D;&#x0A; --proxy.count&#x0D;&#x0A;&#x0D;&#x0A; // after first error, rest are passed to err_cb&#x0D;&#x0A; if (err) {&#x0D;&#x0A; bail = true&#x0D;&#x0A; callback(err)&#x0D;&#x0A; // future error callbacks will go to error handler&#x0D;&#x0A; callback = err_cb&#x0D;&#x0A; } else if (proxy.count === 0 &amp;&amp; !bail) {&#x0D;&#x0A; callback(null, result)&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;function noop() {}&#x0D;&#x0A;&#x0D;&#x0A;},{}],7:[function(_dereq_,module,exports){&#x0D;&#x0A;/**&#x0D;&#x0A; * An abstraction for slicing an arraybuffer even when&#x0D;&#x0A; * ArrayBuffer.prototype.slice is not supported&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function(arraybuffer, start, end) {&#x0D;&#x0A; var bytes = arraybuffer.byteLength;&#x0D;&#x0A; start = start || 0;&#x0D;&#x0A; end = end || bytes;&#x0D;&#x0A;&#x0D;&#x0A; if (arraybuffer.slice) { return arraybuffer.slice(start, end); }&#x0D;&#x0A;&#x0D;&#x0A; if (start &lt; 0) { start += bytes; }&#x0D;&#x0A; if (end &lt; 0) { end += bytes; }&#x0D;&#x0A; if (end &gt; bytes) { end = bytes; }&#x0D;&#x0A;&#x0D;&#x0A; if (start &gt;= bytes || start &gt;= end || bytes === 0) {&#x0D;&#x0A; return new ArrayBuffer(0);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var abv = new Uint8Array(arraybuffer);&#x0D;&#x0A; var result = new Uint8Array(end - start);&#x0D;&#x0A; for (var i = start, ii = 0; i &lt; end; i++, ii++) {&#x0D;&#x0A; result[ii] = abv[i];&#x0D;&#x0A; }&#x0D;&#x0A; return result.buffer;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],8:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Expose `Backoff`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Backoff;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Initialize backoff timer with `opts`.&#x0D;&#x0A; *&#x0D;&#x0A; * - `min` initial timeout in milliseconds [100]&#x0D;&#x0A; * - `max` max timeout [10000]&#x0D;&#x0A; * - `jitter` [0]&#x0D;&#x0A; * - `factor` [2]&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} opts&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Backoff(opts) {&#x0D;&#x0A; opts = opts || {};&#x0D;&#x0A; this.ms = opts.min || 100;&#x0D;&#x0A; this.max = opts.max || 10000;&#x0D;&#x0A; this.factor = opts.factor || 2;&#x0D;&#x0A; this.jitter = opts.jitter &gt; 0 &amp;&amp; opts.jitter &lt;= 1 ? opts.jitter : 0;&#x0D;&#x0A; this.attempts = 0;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Return the backoff duration.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Number}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Backoff.prototype.duration = function(){&#x0D;&#x0A; var ms = this.ms * Math.pow(this.factor, this.attempts++);&#x0D;&#x0A; if (this.jitter) {&#x0D;&#x0A; var rand = Math.random();&#x0D;&#x0A; var deviation = Math.floor(rand * this.jitter * ms);&#x0D;&#x0A; ms = (Math.floor(rand * 10) &amp; 1) == 0 ? ms - deviation : ms + deviation;&#x0D;&#x0A; }&#x0D;&#x0A; return Math.min(ms, this.max) | 0;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Reset the number of attempts.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Backoff.prototype.reset = function(){&#x0D;&#x0A; this.attempts = 0;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Set the minimum duration&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Backoff.prototype.setMin = function(min){&#x0D;&#x0A; this.ms = min;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Set the maximum duration&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Backoff.prototype.setMax = function(max){&#x0D;&#x0A; this.max = max;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Set the jitter&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Backoff.prototype.setJitter = function(jitter){&#x0D;&#x0A; this.jitter = jitter;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;&#x0D;&#x0A;},{}],9:[function(_dereq_,module,exports){&#x0D;&#x0A;/*&#x0D;&#x0A; * base64-arraybuffer&#x0D;&#x0A; * https://github.com/niklasvh/base64-arraybuffer&#x0D;&#x0A; *&#x0D;&#x0A; * Copyright (c) 2012 Niklas von Hertzen&#x0D;&#x0A; * Licensed under the MIT license.&#x0D;&#x0A; */&#x0D;&#x0A;(function(){&#x0D;&#x0A; &quot;use strict&quot;;&#x0D;&#x0A;&#x0D;&#x0A; var chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;&#x0D;&#x0A;&#x0D;&#x0A; // Use a lookup table to find the index.&#x0D;&#x0A; var lookup = new Uint8Array(256);&#x0D;&#x0A; for (var i = 0; i &lt; chars.length; i++) {&#x0D;&#x0A; lookup[chars.charCodeAt(i)] = i;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; exports.encode = function(arraybuffer) {&#x0D;&#x0A; var bytes = new Uint8Array(arraybuffer),&#x0D;&#x0A; i, len = bytes.length, base64 = &quot;&quot;;&#x0D;&#x0A;&#x0D;&#x0A; for (i = 0; i &lt; len; i+=3) {&#x0D;&#x0A; base64 += chars[bytes[i] &gt;&gt; 2];&#x0D;&#x0A; base64 += chars[((bytes[i] &amp; 3) &lt;&lt; 4) | (bytes[i + 1] &gt;&gt; 4)];&#x0D;&#x0A; base64 += chars[((bytes[i + 1] &amp; 15) &lt;&lt; 2) | (bytes[i + 2] &gt;&gt; 6)];&#x0D;&#x0A; base64 += chars[bytes[i + 2] &amp; 63];&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if ((len % 3) === 2) {&#x0D;&#x0A; base64 = base64.substring(0, base64.length - 1) + &quot;=&quot;;&#x0D;&#x0A; } else if (len % 3 === 1) {&#x0D;&#x0A; base64 = base64.substring(0, base64.length - 2) + &quot;==&quot;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return base64;&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; exports.decode = function(base64) {&#x0D;&#x0A; var bufferLength = base64.length * 0.75,&#x0D;&#x0A; len = base64.length, i, p = 0,&#x0D;&#x0A; encoded1, encoded2, encoded3, encoded4;&#x0D;&#x0A;&#x0D;&#x0A; if (base64[base64.length - 1] === &quot;=&quot;) {&#x0D;&#x0A; bufferLength--;&#x0D;&#x0A; if (base64[base64.length - 2] === &quot;=&quot;) {&#x0D;&#x0A; bufferLength--;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var arraybuffer = new ArrayBuffer(bufferLength),&#x0D;&#x0A; bytes = new Uint8Array(arraybuffer);&#x0D;&#x0A;&#x0D;&#x0A; for (i = 0; i &lt; len; i+=4) {&#x0D;&#x0A; encoded1 = lookup[base64.charCodeAt(i)];&#x0D;&#x0A; encoded2 = lookup[base64.charCodeAt(i+1)];&#x0D;&#x0A; encoded3 = lookup[base64.charCodeAt(i+2)];&#x0D;&#x0A; encoded4 = lookup[base64.charCodeAt(i+3)];&#x0D;&#x0A;&#x0D;&#x0A; bytes[p++] = (encoded1 &lt;&lt; 2) | (encoded2 &gt;&gt; 4);&#x0D;&#x0A; bytes[p++] = ((encoded2 &amp; 15) &lt;&lt; 4) | (encoded3 &gt;&gt; 2);&#x0D;&#x0A; bytes[p++] = ((encoded3 &amp; 3) &lt;&lt; 6) | (encoded4 &amp; 63);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return arraybuffer;&#x0D;&#x0A; };&#x0D;&#x0A;})();&#x0D;&#x0A;&#x0D;&#x0A;},{}],10:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/**&#x0D;&#x0A; * Create a blob builder even when vendor prefixes exist&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var BlobBuilder = global.BlobBuilder&#x0D;&#x0A; || global.WebKitBlobBuilder&#x0D;&#x0A; || global.MSBlobBuilder&#x0D;&#x0A; || global.MozBlobBuilder;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if Blob constructor is supported&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var blobSupported = (function() {&#x0D;&#x0A; try {&#x0D;&#x0A; var a = new Blob([&apos;hi&apos;]);&#x0D;&#x0A; return a.size === 2;&#x0D;&#x0A; } catch(e) {&#x0D;&#x0A; return false;&#x0D;&#x0A; }&#x0D;&#x0A;})();&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if Blob constructor supports ArrayBufferViews&#x0D;&#x0A; * Fails in Safari 6, so we need to map to ArrayBuffers there.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var blobSupportsArrayBufferView = blobSupported &amp;&amp; (function() {&#x0D;&#x0A; try {&#x0D;&#x0A; var b = new Blob([new Uint8Array([1,2])]);&#x0D;&#x0A; return b.size === 2;&#x0D;&#x0A; } catch(e) {&#x0D;&#x0A; return false;&#x0D;&#x0A; }&#x0D;&#x0A;})();&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if BlobBuilder is supported&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var blobBuilderSupported = BlobBuilder&#x0D;&#x0A; &amp;&amp; BlobBuilder.prototype.append&#x0D;&#x0A; &amp;&amp; BlobBuilder.prototype.getBlob;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Helper function that maps ArrayBufferViews to ArrayBuffers&#x0D;&#x0A; * Used by BlobBuilder constructor and old browsers that didn&apos;t&#x0D;&#x0A; * support it in the Blob constructor.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function mapArrayBufferViews(ary) {&#x0D;&#x0A; for (var i = 0; i &lt; ary.length; i++) {&#x0D;&#x0A; var chunk = ary[i];&#x0D;&#x0A; if (chunk.buffer instanceof ArrayBuffer) {&#x0D;&#x0A; var buf = chunk.buffer;&#x0D;&#x0A;&#x0D;&#x0A; // if this is a subarray, make a copy so we only&#x0D;&#x0A; // include the subarray region from the underlying buffer&#x0D;&#x0A; if (chunk.byteLength !== buf.byteLength) {&#x0D;&#x0A; var copy = new Uint8Array(chunk.byteLength);&#x0D;&#x0A; copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));&#x0D;&#x0A; buf = copy.buffer;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; ary[i] = buf;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;function BlobBuilderConstructor(ary, options) {&#x0D;&#x0A; options = options || {};&#x0D;&#x0A;&#x0D;&#x0A; var bb = new BlobBuilder();&#x0D;&#x0A; mapArrayBufferViews(ary);&#x0D;&#x0A;&#x0D;&#x0A; for (var i = 0; i &lt; ary.length; i++) {&#x0D;&#x0A; bb.append(ary[i]);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return (options.type) ? bb.getBlob(options.type) : bb.getBlob();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;function BlobConstructor(ary, options) {&#x0D;&#x0A; mapArrayBufferViews(ary);&#x0D;&#x0A; return new Blob(ary, options || {});&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;module.exports = (function() {&#x0D;&#x0A; if (blobSupported) {&#x0D;&#x0A; return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;&#x0D;&#x0A; } else if (blobBuilderSupported) {&#x0D;&#x0A; return BlobBuilderConstructor;&#x0D;&#x0A; } else {&#x0D;&#x0A; return undefined;&#x0D;&#x0A; }&#x0D;&#x0A;})();&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{}],11:[function(_dereq_,module,exports){&#x0D;&#x0A;/**&#x0D;&#x0A; * Slice reference.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var slice = [].slice;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Bind `obj` to `fn`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} obj&#x0D;&#x0A; * @param {Function|String} fn or string&#x0D;&#x0A; * @return {Function}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function(obj, fn){&#x0D;&#x0A; if (&apos;string&apos; == typeof fn) fn = obj[fn];&#x0D;&#x0A; if (&apos;function&apos; != typeof fn) throw new Error(&apos;bind() requires a function&apos;);&#x0D;&#x0A; var args = slice.call(arguments, 2);&#x0D;&#x0A; return function(){&#x0D;&#x0A; return fn.apply(obj, args.concat(slice.call(arguments)));&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],12:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Expose `Emitter`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Emitter;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Initialize a new `Emitter`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Emitter(obj) {&#x0D;&#x0A; if (obj) return mixin(obj);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mixin the emitter properties.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} obj&#x0D;&#x0A; * @return {Object}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function mixin(obj) {&#x0D;&#x0A; for (var key in Emitter.prototype) {&#x0D;&#x0A; obj[key] = Emitter.prototype[key];&#x0D;&#x0A; }&#x0D;&#x0A; return obj;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Listen on the given `event` with `fn`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Function} fn&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.on =&#x0D;&#x0A;Emitter.prototype.addEventListener = function(event, fn){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A; (this._callbacks[&apos;$&apos; + event] = this._callbacks[&apos;$&apos; + event] || [])&#x0D;&#x0A; .push(fn);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Adds an `event` listener that will be invoked a single&#x0D;&#x0A; * time then automatically removed.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Function} fn&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.once = function(event, fn){&#x0D;&#x0A; function on() {&#x0D;&#x0A; this.off(event, on);&#x0D;&#x0A; fn.apply(this, arguments);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; on.fn = fn;&#x0D;&#x0A; this.on(event, on);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Remove the given callback for `event` or all&#x0D;&#x0A; * registered callbacks.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Function} fn&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.off =&#x0D;&#x0A;Emitter.prototype.removeListener =&#x0D;&#x0A;Emitter.prototype.removeAllListeners =&#x0D;&#x0A;Emitter.prototype.removeEventListener = function(event, fn){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A;&#x0D;&#x0A; // all&#x0D;&#x0A; if (0 == arguments.length) {&#x0D;&#x0A; this._callbacks = {};&#x0D;&#x0A; return this;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // specific event&#x0D;&#x0A; var callbacks = this._callbacks[&apos;$&apos; + event];&#x0D;&#x0A; if (!callbacks) return this;&#x0D;&#x0A;&#x0D;&#x0A; // remove all handlers&#x0D;&#x0A; if (1 == arguments.length) {&#x0D;&#x0A; delete this._callbacks[&apos;$&apos; + event];&#x0D;&#x0A; return this;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // remove specific handler&#x0D;&#x0A; var cb;&#x0D;&#x0A; for (var i = 0; i &lt; callbacks.length; i++) {&#x0D;&#x0A; cb = callbacks[i];&#x0D;&#x0A; if (cb === fn || cb.fn === fn) {&#x0D;&#x0A; callbacks.splice(i, 1);&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Emit `event` with the given args.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Mixed} ...&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.emit = function(event){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A; var args = [].slice.call(arguments, 1)&#x0D;&#x0A; , callbacks = this._callbacks[&apos;$&apos; + event];&#x0D;&#x0A;&#x0D;&#x0A; if (callbacks) {&#x0D;&#x0A; callbacks = callbacks.slice(0);&#x0D;&#x0A; for (var i = 0, len = callbacks.length; i &lt; len; ++i) {&#x0D;&#x0A; callbacks[i].apply(this, args);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Return array of callbacks for `event`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @return {Array}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.listeners = function(event){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A; return this._callbacks[&apos;$&apos; + event] || [];&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if this emitter has `event` handlers.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @return {Boolean}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.hasListeners = function(event){&#x0D;&#x0A; return !! this.listeners(event).length;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],13:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function(a, b){&#x0D;&#x0A; var fn = function(){};&#x0D;&#x0A; fn.prototype = b.prototype;&#x0D;&#x0A; a.prototype = new fn;&#x0D;&#x0A; a.prototype.constructor = a;&#x0D;&#x0A;};&#x0D;&#x0A;},{}],14:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * This is the web browser implementation of `debug()`.&#x0D;&#x0A; *&#x0D;&#x0A; * Expose `debug()` as the module.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports = module.exports = _dereq_(&apos;./debug&apos;);&#x0D;&#x0A;exports.log = log;&#x0D;&#x0A;exports.formatArgs = formatArgs;&#x0D;&#x0A;exports.save = save;&#x0D;&#x0A;exports.load = load;&#x0D;&#x0A;exports.useColors = useColors;&#x0D;&#x0A;exports.storage = &apos;undefined&apos; != typeof chrome&#x0D;&#x0A; &amp;&amp; &apos;undefined&apos; != typeof chrome.storage&#x0D;&#x0A; ? chrome.storage.local&#x0D;&#x0A; : localstorage();&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Colors.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.colors = [&#x0D;&#x0A; &apos;lightseagreen&apos;,&#x0D;&#x0A; &apos;forestgreen&apos;,&#x0D;&#x0A; &apos;goldenrod&apos;,&#x0D;&#x0A; &apos;dodgerblue&apos;,&#x0D;&#x0A; &apos;darkorchid&apos;,&#x0D;&#x0A; &apos;crimson&apos;&#x0D;&#x0A;];&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,&#x0D;&#x0A; * and the Firebug extension (any Firefox version) are known&#x0D;&#x0A; * to support &quot;%c&quot; CSS customizations.&#x0D;&#x0A; *&#x0D;&#x0A; * TODO: add a `localStorage` variable to explicitly enable/disable colors&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function useColors() {&#x0D;&#x0A; // is webkit? http://stackoverflow.com/a/16459606/376773&#x0D;&#x0A; return (&apos;WebkitAppearance&apos; in document.documentElement.style) ||&#x0D;&#x0A; // is firebug? http://stackoverflow.com/a/398120/376773&#x0D;&#x0A; (window.console &amp;&amp; (console.firebug || (console.exception &amp;&amp; console.table))) ||&#x0D;&#x0A; // is firefox &gt;= v31?&#x0D;&#x0A; // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages&#x0D;&#x0A; (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &amp;&amp; parseInt(RegExp.$1, 10) &gt;= 31);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.formatters.j = function(v) {&#x0D;&#x0A; return JSON.stringify(v);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Colorize log arguments if enabled.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function formatArgs() {&#x0D;&#x0A; var args = arguments;&#x0D;&#x0A; var useColors = this.useColors;&#x0D;&#x0A;&#x0D;&#x0A; args[0] = (useColors ? &apos;%c&apos; : &apos;&apos;)&#x0D;&#x0A; + this.namespace&#x0D;&#x0A; + (useColors ? &apos; %c&apos; : &apos; &apos;)&#x0D;&#x0A; + args[0]&#x0D;&#x0A; + (useColors ? &apos;%c &apos; : &apos; &apos;)&#x0D;&#x0A; + &apos;+&apos; + exports.humanize(this.diff);&#x0D;&#x0A;&#x0D;&#x0A; if (!useColors) return args;&#x0D;&#x0A;&#x0D;&#x0A; var c = &apos;color: &apos; + this.color;&#x0D;&#x0A; args = [args[0], c, &apos;color: inherit&apos;].concat(Array.prototype.slice.call(args, 1));&#x0D;&#x0A;&#x0D;&#x0A; // the final &quot;%c&quot; is somewhat tricky, because there could be other&#x0D;&#x0A; // arguments passed either before or after the %c, so we need to&#x0D;&#x0A; // figure out the correct index to insert the CSS into&#x0D;&#x0A; var index = 0;&#x0D;&#x0A; var lastC = 0;&#x0D;&#x0A; args[0].replace(/%[a-z%]/g, function(match) {&#x0D;&#x0A; if (&apos;%%&apos; === match) return;&#x0D;&#x0A; index++;&#x0D;&#x0A; if (&apos;%c&apos; === match) {&#x0D;&#x0A; // we only are interested in the *last* %c&#x0D;&#x0A; // (the user may have provided their own)&#x0D;&#x0A; lastC = index;&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; args.splice(lastC, 0, c);&#x0D;&#x0A; return args;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Invokes `console.log()` when available.&#x0D;&#x0A; * No-op when `console.log` is not a &quot;function&quot;.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function log() {&#x0D;&#x0A; // this hackery is required for IE8/9, where&#x0D;&#x0A; // the `console.log` function doesn&apos;t have &apos;apply&apos;&#x0D;&#x0A; return &apos;object&apos; === typeof console&#x0D;&#x0A; &amp;&amp; console.log&#x0D;&#x0A; &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Save `namespaces`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} namespaces&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function save(namespaces) {&#x0D;&#x0A; try {&#x0D;&#x0A; if (null == namespaces) {&#x0D;&#x0A; exports.storage.removeItem(&apos;debug&apos;);&#x0D;&#x0A; } else {&#x0D;&#x0A; exports.storage.debug = namespaces;&#x0D;&#x0A; }&#x0D;&#x0A; } catch(e) {}&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Load `namespaces`.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {String} returns the previously persisted debug modes&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function load() {&#x0D;&#x0A; var r;&#x0D;&#x0A; try {&#x0D;&#x0A; r = exports.storage.debug;&#x0D;&#x0A; } catch(e) {}&#x0D;&#x0A; return r;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Enable namespaces listed in `localStorage.debug` initially.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.enable(load());&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Localstorage attempts to return the localstorage.&#x0D;&#x0A; *&#x0D;&#x0A; * This is necessary because safari throws&#x0D;&#x0A; * when a user disables cookies/localstorage&#x0D;&#x0A; * and you attempt to access it.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {LocalStorage}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function localstorage(){&#x0D;&#x0A; try {&#x0D;&#x0A; return window.localStorage;&#x0D;&#x0A; } catch (e) {}&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;./debug&quot;:15}],15:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * This is the common logic for both the Node.js and web browser&#x0D;&#x0A; * implementations of `debug()`.&#x0D;&#x0A; *&#x0D;&#x0A; * Expose `debug()` as the module.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports = module.exports = debug;&#x0D;&#x0A;exports.coerce = coerce;&#x0D;&#x0A;exports.disable = disable;&#x0D;&#x0A;exports.enable = enable;&#x0D;&#x0A;exports.enabled = enabled;&#x0D;&#x0A;exports.humanize = _dereq_(&apos;ms&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * The currently active debug mode names, and names to skip.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.names = [];&#x0D;&#x0A;exports.skips = [];&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.&#x0D;&#x0A; *&#x0D;&#x0A; * Valid key names are a single, lowercased letter, i.e. &quot;n&quot;.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.formatters = {};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Previously assigned color.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var prevColor = 0;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Previous log timestamp.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var prevTime;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Select a color.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Number}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function selectColor() {&#x0D;&#x0A; return exports.colors[prevColor++ % exports.colors.length];&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Create a debugger with the given `namespace`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} namespace&#x0D;&#x0A; * @return {Function}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function debug(namespace) {&#x0D;&#x0A;&#x0D;&#x0A; // define the `disabled` version&#x0D;&#x0A; function disabled() {&#x0D;&#x0A; }&#x0D;&#x0A; disabled.enabled = false;&#x0D;&#x0A;&#x0D;&#x0A; // define the `enabled` version&#x0D;&#x0A; function enabled() {&#x0D;&#x0A;&#x0D;&#x0A; var self = enabled;&#x0D;&#x0A;&#x0D;&#x0A; // set `diff` timestamp&#x0D;&#x0A; var curr = +new Date();&#x0D;&#x0A; var ms = curr - (prevTime || curr);&#x0D;&#x0A; self.diff = ms;&#x0D;&#x0A; self.prev = prevTime;&#x0D;&#x0A; self.curr = curr;&#x0D;&#x0A; prevTime = curr;&#x0D;&#x0A;&#x0D;&#x0A; // add the `color` if not set&#x0D;&#x0A; if (null == self.useColors) self.useColors = exports.useColors();&#x0D;&#x0A; if (null == self.color &amp;&amp; self.useColors) self.color = selectColor();&#x0D;&#x0A;&#x0D;&#x0A; var args = Array.prototype.slice.call(arguments);&#x0D;&#x0A;&#x0D;&#x0A; args[0] = exports.coerce(args[0]);&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;string&apos; !== typeof args[0]) {&#x0D;&#x0A; // anything else let&apos;s inspect with %o&#x0D;&#x0A; args = [&apos;%o&apos;].concat(args);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // apply any `formatters` transformations&#x0D;&#x0A; var index = 0;&#x0D;&#x0A; args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {&#x0D;&#x0A; // if we encounter an escaped % then don&apos;t increase the array index&#x0D;&#x0A; if (match === &apos;%%&apos;) return match;&#x0D;&#x0A; index++;&#x0D;&#x0A; var formatter = exports.formatters[format];&#x0D;&#x0A; if (&apos;function&apos; === typeof formatter) {&#x0D;&#x0A; var val = args[index];&#x0D;&#x0A; match = formatter.call(self, val);&#x0D;&#x0A;&#x0D;&#x0A; // now we need to remove `args[index]` since it&apos;s inlined in the `format`&#x0D;&#x0A; args.splice(index, 1);&#x0D;&#x0A; index--;&#x0D;&#x0A; }&#x0D;&#x0A; return match;&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;function&apos; === typeof exports.formatArgs) {&#x0D;&#x0A; args = exports.formatArgs.apply(self, args);&#x0D;&#x0A; }&#x0D;&#x0A; var logFn = enabled.log || exports.log || console.log.bind(console);&#x0D;&#x0A; logFn.apply(self, args);&#x0D;&#x0A; }&#x0D;&#x0A; enabled.enabled = true;&#x0D;&#x0A;&#x0D;&#x0A; var fn = exports.enabled(namespace) ? enabled : disabled;&#x0D;&#x0A;&#x0D;&#x0A; fn.namespace = namespace;&#x0D;&#x0A;&#x0D;&#x0A; return fn;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Enables a debug mode by namespaces. This can include modes&#x0D;&#x0A; * separated by a colon and wildcards.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} namespaces&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function enable(namespaces) {&#x0D;&#x0A; exports.save(namespaces);&#x0D;&#x0A;&#x0D;&#x0A; var split = (namespaces || &apos;&apos;).split(/[\s,]+/);&#x0D;&#x0A; var len = split.length;&#x0D;&#x0A;&#x0D;&#x0A; for (var i = 0; i &lt; len; i++) {&#x0D;&#x0A; if (!split[i]) continue; // ignore empty strings&#x0D;&#x0A; namespaces = split[i].replace(/\*/g, &apos;.*?&apos;);&#x0D;&#x0A; if (namespaces[0] === &apos;-&apos;) {&#x0D;&#x0A; exports.skips.push(new RegExp(&apos;^&apos; + namespaces.substr(1) + &apos;$&apos;));&#x0D;&#x0A; } else {&#x0D;&#x0A; exports.names.push(new RegExp(&apos;^&apos; + namespaces + &apos;$&apos;));&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Disable debug output.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function disable() {&#x0D;&#x0A; exports.enable(&apos;&apos;);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Returns true if the given mode name is enabled, false otherwise.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} name&#x0D;&#x0A; * @return {Boolean}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function enabled(name) {&#x0D;&#x0A; var i, len;&#x0D;&#x0A; for (i = 0, len = exports.skips.length; i &lt; len; i++) {&#x0D;&#x0A; if (exports.skips[i].test(name)) {&#x0D;&#x0A; return false;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; for (i = 0, len = exports.names.length; i &lt; len; i++) {&#x0D;&#x0A; if (exports.names[i].test(name)) {&#x0D;&#x0A; return true;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return false;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Coerce `val`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Mixed} val&#x0D;&#x0A; * @return {Mixed}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function coerce(val) {&#x0D;&#x0A; if (val instanceof Error) return val.stack || val.message;&#x0D;&#x0A; return val;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;ms&quot;:35}],16:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;module.exports = _dereq_(&apos;./lib/&apos;);&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;./lib/&quot;:17}],17:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;module.exports = _dereq_(&apos;./socket&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Exports parser&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; *&#x0D;&#x0A; */&#x0D;&#x0A;module.exports.parser = _dereq_(&apos;engine.io-parser&apos;);&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;./socket&quot;:18,&quot;engine.io-parser&quot;:27}],18:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var transports = _dereq_(&apos;./transports&apos;);&#x0D;&#x0A;var Emitter = _dereq_(&apos;component-emitter&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:socket&apos;);&#x0D;&#x0A;var index = _dereq_(&apos;indexof&apos;);&#x0D;&#x0A;var parser = _dereq_(&apos;engine.io-parser&apos;);&#x0D;&#x0A;var parseuri = _dereq_(&apos;parseuri&apos;);&#x0D;&#x0A;var parsejson = _dereq_(&apos;parsejson&apos;);&#x0D;&#x0A;var parseqs = _dereq_(&apos;parseqs&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Socket;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Noop function.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function noop(){}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Socket constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String|Object} uri or options&#x0D;&#x0A; * @param {Object} options&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Socket(uri, opts){&#x0D;&#x0A; if (!(this instanceof Socket)) return new Socket(uri, opts);&#x0D;&#x0A;&#x0D;&#x0A; opts = opts || {};&#x0D;&#x0A;&#x0D;&#x0A; if (uri &amp;&amp; &apos;object&apos; == typeof uri) {&#x0D;&#x0A; opts = uri;&#x0D;&#x0A; uri = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (uri) {&#x0D;&#x0A; uri = parseuri(uri);&#x0D;&#x0A; opts.hostname = uri.host;&#x0D;&#x0A; opts.secure = uri.protocol == &apos;https&apos; || uri.protocol == &apos;wss&apos;;&#x0D;&#x0A; opts.port = uri.port;&#x0D;&#x0A; if (uri.query) opts.query = uri.query;&#x0D;&#x0A; } else if (opts.host) {&#x0D;&#x0A; opts.hostname = parseuri(opts.host).host;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.secure = null != opts.secure ? opts.secure :&#x0D;&#x0A; (global.location &amp;&amp; &apos;https:&apos; == location.protocol);&#x0D;&#x0A;&#x0D;&#x0A; if (opts.hostname &amp;&amp; !opts.port) {&#x0D;&#x0A; // if no port is specified manually, use the protocol default&#x0D;&#x0A; opts.port = this.secure ? &apos;443&apos; : &apos;80&apos;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.agent = opts.agent || false;&#x0D;&#x0A; this.hostname = opts.hostname ||&#x0D;&#x0A; (global.location ? location.hostname : &apos;localhost&apos;);&#x0D;&#x0A; this.port = opts.port || (global.location &amp;&amp; location.port ?&#x0D;&#x0A; location.port :&#x0D;&#x0A; (this.secure ? 443 : 80));&#x0D;&#x0A; this.query = opts.query || {};&#x0D;&#x0A; if (&apos;string&apos; == typeof this.query) this.query = parseqs.decode(this.query);&#x0D;&#x0A; this.upgrade = false !== opts.upgrade;&#x0D;&#x0A; this.path = (opts.path || &apos;/engine.io&apos;).replace(/\/$/, &apos;&apos;) + &apos;/&apos;;&#x0D;&#x0A; this.forceJSONP = !!opts.forceJSONP;&#x0D;&#x0A; this.jsonp = false !== opts.jsonp;&#x0D;&#x0A; this.forceBase64 = !!opts.forceBase64;&#x0D;&#x0A; this.enablesXDR = !!opts.enablesXDR;&#x0D;&#x0A; this.timestampParam = opts.timestampParam || &apos;t&apos;;&#x0D;&#x0A; this.timestampRequests = opts.timestampRequests;&#x0D;&#x0A; this.transports = opts.transports || [&apos;polling&apos;, &apos;websocket&apos;];&#x0D;&#x0A; this.readyState = &apos;&apos;;&#x0D;&#x0A; this.writeBuffer = [];&#x0D;&#x0A; this.policyPort = opts.policyPort || 843;&#x0D;&#x0A; this.rememberUpgrade = opts.rememberUpgrade || false;&#x0D;&#x0A; this.binaryType = null;&#x0D;&#x0A; this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;&#x0D;&#x0A; this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;&#x0D;&#x0A;&#x0D;&#x0A; if (true === this.perMessageDeflate) this.perMessageDeflate = {};&#x0D;&#x0A; if (this.perMessageDeflate &amp;&amp; null == this.perMessageDeflate.threshold) {&#x0D;&#x0A; this.perMessageDeflate.threshold = 1024;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // SSL options for Node.js client&#x0D;&#x0A; this.pfx = opts.pfx || null;&#x0D;&#x0A; this.key = opts.key || null;&#x0D;&#x0A; this.passphrase = opts.passphrase || null;&#x0D;&#x0A; this.cert = opts.cert || null;&#x0D;&#x0A; this.ca = opts.ca || null;&#x0D;&#x0A; this.ciphers = opts.ciphers || null;&#x0D;&#x0A; this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;&#x0D;&#x0A;&#x0D;&#x0A; // other options for Node.js client&#x0D;&#x0A; var freeGlobal = typeof global == &apos;object&apos; &amp;&amp; global;&#x0D;&#x0A; if (freeGlobal.global === freeGlobal) {&#x0D;&#x0A; if (opts.extraHeaders &amp;&amp; Object.keys(opts.extraHeaders).length &gt; 0) {&#x0D;&#x0A; this.extraHeaders = opts.extraHeaders;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.open();&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;Socket.priorWebsocketSuccess = false;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mix in `Emitter`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter(Socket.prototype);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Protocol version.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.protocol = parser.protocol; // this is an int&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Expose deps for legacy compatibility&#x0D;&#x0A; * and standalone browser access.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.Socket = Socket;&#x0D;&#x0A;Socket.Transport = _dereq_(&apos;./transport&apos;);&#x0D;&#x0A;Socket.transports = _dereq_(&apos;./transports&apos;);&#x0D;&#x0A;Socket.parser = _dereq_(&apos;engine.io-parser&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Creates transport of the given type.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} transport name&#x0D;&#x0A; * @return {Transport}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.createTransport = function (name) {&#x0D;&#x0A; debug(&apos;creating transport &quot;%s&quot;&apos;, name);&#x0D;&#x0A; var query = clone(this.query);&#x0D;&#x0A;&#x0D;&#x0A; // append engine.io protocol identifier&#x0D;&#x0A; query.EIO = parser.protocol;&#x0D;&#x0A;&#x0D;&#x0A; // transport name&#x0D;&#x0A; query.transport = name;&#x0D;&#x0A;&#x0D;&#x0A; // session id if we already have one&#x0D;&#x0A; if (this.id) query.sid = this.id;&#x0D;&#x0A;&#x0D;&#x0A; var transport = new transports[name]({&#x0D;&#x0A; agent: this.agent,&#x0D;&#x0A; hostname: this.hostname,&#x0D;&#x0A; port: this.port,&#x0D;&#x0A; secure: this.secure,&#x0D;&#x0A; path: this.path,&#x0D;&#x0A; query: query,&#x0D;&#x0A; forceJSONP: this.forceJSONP,&#x0D;&#x0A; jsonp: this.jsonp,&#x0D;&#x0A; forceBase64: this.forceBase64,&#x0D;&#x0A; enablesXDR: this.enablesXDR,&#x0D;&#x0A; timestampRequests: this.timestampRequests,&#x0D;&#x0A; timestampParam: this.timestampParam,&#x0D;&#x0A; policyPort: this.policyPort,&#x0D;&#x0A; socket: this,&#x0D;&#x0A; pfx: this.pfx,&#x0D;&#x0A; key: this.key,&#x0D;&#x0A; passphrase: this.passphrase,&#x0D;&#x0A; cert: this.cert,&#x0D;&#x0A; ca: this.ca,&#x0D;&#x0A; ciphers: this.ciphers,&#x0D;&#x0A; rejectUnauthorized: this.rejectUnauthorized,&#x0D;&#x0A; perMessageDeflate: this.perMessageDeflate,&#x0D;&#x0A; extraHeaders: this.extraHeaders&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; return transport;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;function clone (obj) {&#x0D;&#x0A; var o = {};&#x0D;&#x0A; for (var i in obj) {&#x0D;&#x0A; if (obj.hasOwnProperty(i)) {&#x0D;&#x0A; o[i] = obj[i];&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return o;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Initializes transport to use and starts probe.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;Socket.prototype.open = function () {&#x0D;&#x0A; var transport;&#x0D;&#x0A; if (this.rememberUpgrade &amp;&amp; Socket.priorWebsocketSuccess &amp;&amp; this.transports.indexOf(&apos;websocket&apos;) != -1) {&#x0D;&#x0A; transport = &apos;websocket&apos;;&#x0D;&#x0A; } else if (0 === this.transports.length) {&#x0D;&#x0A; // Emit error on next tick so it can be listened to&#x0D;&#x0A; var self = this;&#x0D;&#x0A; setTimeout(function() {&#x0D;&#x0A; self.emit(&apos;error&apos;, &apos;No transports available&apos;);&#x0D;&#x0A; }, 0);&#x0D;&#x0A; return;&#x0D;&#x0A; } else {&#x0D;&#x0A; transport = this.transports[0];&#x0D;&#x0A; }&#x0D;&#x0A; this.readyState = &apos;opening&apos;;&#x0D;&#x0A;&#x0D;&#x0A; // Retry with the next transport if the transport is disabled (jsonp: false)&#x0D;&#x0A; try {&#x0D;&#x0A; transport = this.createTransport(transport);&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; this.transports.shift();&#x0D;&#x0A; this.open();&#x0D;&#x0A; return;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; transport.open();&#x0D;&#x0A; this.setTransport(transport);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sets the current transport. Disables the existing one (if any).&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.setTransport = function(transport){&#x0D;&#x0A; debug(&apos;setting transport %s&apos;, transport.name);&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; if (this.transport) {&#x0D;&#x0A; debug(&apos;clearing existing transport %s&apos;, this.transport.name);&#x0D;&#x0A; this.transport.removeAllListeners();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // set up transport&#x0D;&#x0A; this.transport = transport;&#x0D;&#x0A;&#x0D;&#x0A; // set up transport listeners&#x0D;&#x0A; transport&#x0D;&#x0A; .on(&apos;drain&apos;, function(){&#x0D;&#x0A; self.onDrain();&#x0D;&#x0A; })&#x0D;&#x0A; .on(&apos;packet&apos;, function(packet){&#x0D;&#x0A; self.onPacket(packet);&#x0D;&#x0A; })&#x0D;&#x0A; .on(&apos;error&apos;, function(e){&#x0D;&#x0A; self.onError(e);&#x0D;&#x0A; })&#x0D;&#x0A; .on(&apos;close&apos;, function(){&#x0D;&#x0A; self.onClose(&apos;transport close&apos;);&#x0D;&#x0A; });&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Probes a transport.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} transport name&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.probe = function (name) {&#x0D;&#x0A; debug(&apos;probing transport &quot;%s&quot;&apos;, name);&#x0D;&#x0A; var transport = this.createTransport(name, { probe: 1 })&#x0D;&#x0A; , failed = false&#x0D;&#x0A; , self = this;&#x0D;&#x0A;&#x0D;&#x0A; Socket.priorWebsocketSuccess = false;&#x0D;&#x0A;&#x0D;&#x0A; function onTransportOpen(){&#x0D;&#x0A; if (self.onlyBinaryUpgrades) {&#x0D;&#x0A; var upgradeLosesBinary = !this.supportsBinary &amp;&amp; self.transport.supportsBinary;&#x0D;&#x0A; failed = failed || upgradeLosesBinary;&#x0D;&#x0A; }&#x0D;&#x0A; if (failed) return;&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;probe transport &quot;%s&quot; opened&apos;, name);&#x0D;&#x0A; transport.send([{ type: &apos;ping&apos;, data: &apos;probe&apos; }]);&#x0D;&#x0A; transport.once(&apos;packet&apos;, function (msg) {&#x0D;&#x0A; if (failed) return;&#x0D;&#x0A; if (&apos;pong&apos; == msg.type &amp;&amp; &apos;probe&apos; == msg.data) {&#x0D;&#x0A; debug(&apos;probe transport &quot;%s&quot; pong&apos;, name);&#x0D;&#x0A; self.upgrading = true;&#x0D;&#x0A; self.emit(&apos;upgrading&apos;, transport);&#x0D;&#x0A; if (!transport) return;&#x0D;&#x0A; Socket.priorWebsocketSuccess = &apos;websocket&apos; == transport.name;&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;pausing current transport &quot;%s&quot;&apos;, self.transport.name);&#x0D;&#x0A; self.transport.pause(function () {&#x0D;&#x0A; if (failed) return;&#x0D;&#x0A; if (&apos;closed&apos; == self.readyState) return;&#x0D;&#x0A; debug(&apos;changing transport and sending upgrade packet&apos;);&#x0D;&#x0A;&#x0D;&#x0A; cleanup();&#x0D;&#x0A;&#x0D;&#x0A; self.setTransport(transport);&#x0D;&#x0A; transport.send([{ type: &apos;upgrade&apos; }]);&#x0D;&#x0A; self.emit(&apos;upgrade&apos;, transport);&#x0D;&#x0A; transport = null;&#x0D;&#x0A; self.upgrading = false;&#x0D;&#x0A; self.flush();&#x0D;&#x0A; });&#x0D;&#x0A; } else {&#x0D;&#x0A; debug(&apos;probe transport &quot;%s&quot; failed&apos;, name);&#x0D;&#x0A; var err = new Error(&apos;probe error&apos;);&#x0D;&#x0A; err.transport = transport.name;&#x0D;&#x0A; self.emit(&apos;upgradeError&apos;, err);&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function freezeTransport() {&#x0D;&#x0A; if (failed) return;&#x0D;&#x0A;&#x0D;&#x0A; // Any callback called by transport should be ignored since now&#x0D;&#x0A; failed = true;&#x0D;&#x0A;&#x0D;&#x0A; cleanup();&#x0D;&#x0A;&#x0D;&#x0A; transport.close();&#x0D;&#x0A; transport = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; //Handle any error that happens while probing&#x0D;&#x0A; function onerror(err) {&#x0D;&#x0A; var error = new Error(&apos;probe error: &apos; + err);&#x0D;&#x0A; error.transport = transport.name;&#x0D;&#x0A;&#x0D;&#x0A; freezeTransport();&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;probe transport &quot;%s&quot; failed because of error: %s&apos;, name, err);&#x0D;&#x0A;&#x0D;&#x0A; self.emit(&apos;upgradeError&apos;, error);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function onTransportClose(){&#x0D;&#x0A; onerror(&quot;transport closed&quot;);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; //When the socket is closed while we&apos;re probing&#x0D;&#x0A; function onclose(){&#x0D;&#x0A; onerror(&quot;socket closed&quot;);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; //When the socket is upgraded while we&apos;re probing&#x0D;&#x0A; function onupgrade(to){&#x0D;&#x0A; if (transport &amp;&amp; to.name != transport.name) {&#x0D;&#x0A; debug(&apos;&quot;%s&quot; works - aborting &quot;%s&quot;&apos;, to.name, transport.name);&#x0D;&#x0A; freezeTransport();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; //Remove all listeners on the transport and on self&#x0D;&#x0A; function cleanup(){&#x0D;&#x0A; transport.removeListener(&apos;open&apos;, onTransportOpen);&#x0D;&#x0A; transport.removeListener(&apos;error&apos;, onerror);&#x0D;&#x0A; transport.removeListener(&apos;close&apos;, onTransportClose);&#x0D;&#x0A; self.removeListener(&apos;close&apos;, onclose);&#x0D;&#x0A; self.removeListener(&apos;upgrading&apos;, onupgrade);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; transport.once(&apos;open&apos;, onTransportOpen);&#x0D;&#x0A; transport.once(&apos;error&apos;, onerror);&#x0D;&#x0A; transport.once(&apos;close&apos;, onTransportClose);&#x0D;&#x0A;&#x0D;&#x0A; this.once(&apos;close&apos;, onclose);&#x0D;&#x0A; this.once(&apos;upgrading&apos;, onupgrade);&#x0D;&#x0A;&#x0D;&#x0A; transport.open();&#x0D;&#x0A;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called when connection is deemed open.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onOpen = function () {&#x0D;&#x0A; debug(&apos;socket open&apos;);&#x0D;&#x0A; this.readyState = &apos;open&apos;;&#x0D;&#x0A; Socket.priorWebsocketSuccess = &apos;websocket&apos; == this.transport.name;&#x0D;&#x0A; this.emit(&apos;open&apos;);&#x0D;&#x0A; this.flush();&#x0D;&#x0A;&#x0D;&#x0A; // we check for `readyState` in case an `open`&#x0D;&#x0A; // listener already closed the socket&#x0D;&#x0A; if (&apos;open&apos; == this.readyState &amp;&amp; this.upgrade &amp;&amp; this.transport.pause) {&#x0D;&#x0A; debug(&apos;starting upgrade probes&apos;);&#x0D;&#x0A; for (var i = 0, l = this.upgrades.length; i &lt; l; i++) {&#x0D;&#x0A; this.probe(this.upgrades[i]);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Handles a packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onPacket = function (packet) {&#x0D;&#x0A; if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {&#x0D;&#x0A; debug(&apos;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&apos;, packet.type, packet.data);&#x0D;&#x0A;&#x0D;&#x0A; this.emit(&apos;packet&apos;, packet);&#x0D;&#x0A;&#x0D;&#x0A; // Socket is live - any packet counts&#x0D;&#x0A; this.emit(&apos;heartbeat&apos;);&#x0D;&#x0A;&#x0D;&#x0A; switch (packet.type) {&#x0D;&#x0A; case &apos;open&apos;:&#x0D;&#x0A; this.onHandshake(parsejson(packet.data));&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case &apos;pong&apos;:&#x0D;&#x0A; this.setPing();&#x0D;&#x0A; this.emit(&apos;pong&apos;);&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case &apos;error&apos;:&#x0D;&#x0A; var err = new Error(&apos;server error&apos;);&#x0D;&#x0A; err.code = packet.data;&#x0D;&#x0A; this.onError(err);&#x0D;&#x0A; break;&#x0D;&#x0A;&#x0D;&#x0A; case &apos;message&apos;:&#x0D;&#x0A; this.emit(&apos;data&apos;, packet.data);&#x0D;&#x0A; this.emit(&apos;message&apos;, packet.data);&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; } else {&#x0D;&#x0A; debug(&apos;packet received with socket readyState &quot;%s&quot;&apos;, this.readyState);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon handshake completion.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} handshake obj&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onHandshake = function (data) {&#x0D;&#x0A; this.emit(&apos;handshake&apos;, data);&#x0D;&#x0A; this.id = data.sid;&#x0D;&#x0A; this.transport.query.sid = data.sid;&#x0D;&#x0A; this.upgrades = this.filterUpgrades(data.upgrades);&#x0D;&#x0A; this.pingInterval = data.pingInterval;&#x0D;&#x0A; this.pingTimeout = data.pingTimeout;&#x0D;&#x0A; this.onOpen();&#x0D;&#x0A; // In case open handler closes socket&#x0D;&#x0A; if (&apos;closed&apos; == this.readyState) return;&#x0D;&#x0A; this.setPing();&#x0D;&#x0A;&#x0D;&#x0A; // Prolong liveness of socket on heartbeat&#x0D;&#x0A; this.removeListener(&apos;heartbeat&apos;, this.onHeartbeat);&#x0D;&#x0A; this.on(&apos;heartbeat&apos;, this.onHeartbeat);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Resets ping timeout.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onHeartbeat = function (timeout) {&#x0D;&#x0A; clearTimeout(this.pingTimeoutTimer);&#x0D;&#x0A; var self = this;&#x0D;&#x0A; self.pingTimeoutTimer = setTimeout(function () {&#x0D;&#x0A; if (&apos;closed&apos; == self.readyState) return;&#x0D;&#x0A; self.onClose(&apos;ping timeout&apos;);&#x0D;&#x0A; }, timeout || (self.pingInterval + self.pingTimeout));&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Pings server every `this.pingInterval` and expects response&#x0D;&#x0A; * within `this.pingTimeout` or closes connection.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.setPing = function () {&#x0D;&#x0A; var self = this;&#x0D;&#x0A; clearTimeout(self.pingIntervalTimer);&#x0D;&#x0A; self.pingIntervalTimer = setTimeout(function () {&#x0D;&#x0A; debug(&apos;writing ping packet - expecting pong within %sms&apos;, self.pingTimeout);&#x0D;&#x0A; self.ping();&#x0D;&#x0A; self.onHeartbeat(self.pingTimeout);&#x0D;&#x0A; }, self.pingInterval);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A;* Sends a ping packet.&#x0D;&#x0A;*&#x0D;&#x0A;* @api private&#x0D;&#x0A;*/&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.ping = function () {&#x0D;&#x0A; var self = this;&#x0D;&#x0A; this.sendPacket(&apos;ping&apos;, function(){&#x0D;&#x0A; self.emit(&apos;ping&apos;);&#x0D;&#x0A; });&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called on `drain` event&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onDrain = function() {&#x0D;&#x0A; this.writeBuffer.splice(0, this.prevBufferLen);&#x0D;&#x0A;&#x0D;&#x0A; // setting prevBufferLen = 0 is very important&#x0D;&#x0A; // for example, when upgrading, upgrade packet is sent over,&#x0D;&#x0A; // and a nonzero prevBufferLen could cause problems on `drain`&#x0D;&#x0A; this.prevBufferLen = 0;&#x0D;&#x0A;&#x0D;&#x0A; if (0 === this.writeBuffer.length) {&#x0D;&#x0A; this.emit(&apos;drain&apos;);&#x0D;&#x0A; } else {&#x0D;&#x0A; this.flush();&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Flush write buffers.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.flush = function () {&#x0D;&#x0A; if (&apos;closed&apos; != this.readyState &amp;&amp; this.transport.writable &amp;&amp;&#x0D;&#x0A; !this.upgrading &amp;&amp; this.writeBuffer.length) {&#x0D;&#x0A; debug(&apos;flushing %d packets in socket&apos;, this.writeBuffer.length);&#x0D;&#x0A; this.transport.send(this.writeBuffer);&#x0D;&#x0A; // keep track of current length of writeBuffer&#x0D;&#x0A; // splice writeBuffer and callbackBuffer on `drain`&#x0D;&#x0A; this.prevBufferLen = this.writeBuffer.length;&#x0D;&#x0A; this.emit(&apos;flush&apos;);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sends a message.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} message.&#x0D;&#x0A; * @param {Function} callback function.&#x0D;&#x0A; * @param {Object} options.&#x0D;&#x0A; * @return {Socket} for chaining.&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.write =&#x0D;&#x0A;Socket.prototype.send = function (msg, options, fn) {&#x0D;&#x0A; this.sendPacket(&apos;message&apos;, msg, options, fn);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sends a packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} packet type.&#x0D;&#x0A; * @param {String} data.&#x0D;&#x0A; * @param {Object} options.&#x0D;&#x0A; * @param {Function} callback function.&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.sendPacket = function (type, data, options, fn) {&#x0D;&#x0A; if(&apos;function&apos; == typeof data) {&#x0D;&#x0A; fn = data;&#x0D;&#x0A; data = undefined;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;function&apos; == typeof options) {&#x0D;&#x0A; fn = options;&#x0D;&#x0A; options = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;closing&apos; == this.readyState || &apos;closed&apos; == this.readyState) {&#x0D;&#x0A; return;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; options = options || {};&#x0D;&#x0A; options.compress = false !== options.compress;&#x0D;&#x0A;&#x0D;&#x0A; var packet = {&#x0D;&#x0A; type: type,&#x0D;&#x0A; data: data,&#x0D;&#x0A; options: options&#x0D;&#x0A; };&#x0D;&#x0A; this.emit(&apos;packetCreate&apos;, packet);&#x0D;&#x0A; this.writeBuffer.push(packet);&#x0D;&#x0A; if (fn) this.once(&apos;flush&apos;, fn);&#x0D;&#x0A; this.flush();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Closes the connection.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.close = function () {&#x0D;&#x0A; if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {&#x0D;&#x0A; this.readyState = &apos;closing&apos;;&#x0D;&#x0A;&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; if (this.writeBuffer.length) {&#x0D;&#x0A; this.once(&apos;drain&apos;, function() {&#x0D;&#x0A; if (this.upgrading) {&#x0D;&#x0A; waitForUpgrade();&#x0D;&#x0A; } else {&#x0D;&#x0A; close();&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A; } else if (this.upgrading) {&#x0D;&#x0A; waitForUpgrade();&#x0D;&#x0A; } else {&#x0D;&#x0A; close();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function close() {&#x0D;&#x0A; self.onClose(&apos;forced close&apos;);&#x0D;&#x0A; debug(&apos;socket closing - telling transport to close&apos;);&#x0D;&#x0A; self.transport.close();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function cleanupAndClose() {&#x0D;&#x0A; self.removeListener(&apos;upgrade&apos;, cleanupAndClose);&#x0D;&#x0A; self.removeListener(&apos;upgradeError&apos;, cleanupAndClose);&#x0D;&#x0A; close();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function waitForUpgrade() {&#x0D;&#x0A; // wait for upgrade to finish since we can&apos;t send packets while pausing a transport&#x0D;&#x0A; self.once(&apos;upgrade&apos;, cleanupAndClose);&#x0D;&#x0A; self.once(&apos;upgradeError&apos;, cleanupAndClose);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon transport error&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onError = function (err) {&#x0D;&#x0A; debug(&apos;socket error %j&apos;, err);&#x0D;&#x0A; Socket.priorWebsocketSuccess = false;&#x0D;&#x0A; this.emit(&apos;error&apos;, err);&#x0D;&#x0A; this.onClose(&apos;transport error&apos;, err);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon transport close.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.onClose = function (reason, desc) {&#x0D;&#x0A; if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState || &apos;closing&apos; == this.readyState) {&#x0D;&#x0A; debug(&apos;socket close with reason: &quot;%s&quot;&apos;, reason);&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; // clear timers&#x0D;&#x0A; clearTimeout(this.pingIntervalTimer);&#x0D;&#x0A; clearTimeout(this.pingTimeoutTimer);&#x0D;&#x0A;&#x0D;&#x0A; // stop event from firing again for transport&#x0D;&#x0A; this.transport.removeAllListeners(&apos;close&apos;);&#x0D;&#x0A;&#x0D;&#x0A; // ensure transport won&apos;t stay open&#x0D;&#x0A; this.transport.close();&#x0D;&#x0A;&#x0D;&#x0A; // ignore further transport communication&#x0D;&#x0A; this.transport.removeAllListeners();&#x0D;&#x0A;&#x0D;&#x0A; // set ready state&#x0D;&#x0A; this.readyState = &apos;closed&apos;;&#x0D;&#x0A;&#x0D;&#x0A; // clear session id&#x0D;&#x0A; this.id = null;&#x0D;&#x0A;&#x0D;&#x0A; // emit close event&#x0D;&#x0A; this.emit(&apos;close&apos;, reason, desc);&#x0D;&#x0A;&#x0D;&#x0A; // clean buffers after, so users can still&#x0D;&#x0A; // grab the buffers on `close` event&#x0D;&#x0A; self.writeBuffer = [];&#x0D;&#x0A; self.prevBufferLen = 0;&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Filters upgrades, returning only those matching client transports.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Array} server upgrades&#x0D;&#x0A; * @api private&#x0D;&#x0A; *&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Socket.prototype.filterUpgrades = function (upgrades) {&#x0D;&#x0A; var filteredUpgrades = [];&#x0D;&#x0A; for (var i = 0, j = upgrades.length; i&lt;j; i++) {&#x0D;&#x0A; if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);&#x0D;&#x0A; }&#x0D;&#x0A; return filteredUpgrades;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;./transport&quot;:19,&quot;./transports&quot;:20,&quot;component-emitter&quot;:26,&quot;debug&quot;:14,&quot;engine.io-parser&quot;:27,&quot;indexof&quot;:32,&quot;parsejson&quot;:36,&quot;parseqs&quot;:37,&quot;parseuri&quot;:38}],19:[function(_dereq_,module,exports){&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var parser = _dereq_(&apos;engine.io-parser&apos;);&#x0D;&#x0A;var Emitter = _dereq_(&apos;component-emitter&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Transport;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Transport abstract constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} options.&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Transport (opts) {&#x0D;&#x0A; this.path = opts.path;&#x0D;&#x0A; this.hostname = opts.hostname;&#x0D;&#x0A; this.port = opts.port;&#x0D;&#x0A; this.secure = opts.secure;&#x0D;&#x0A; this.query = opts.query;&#x0D;&#x0A; this.timestampParam = opts.timestampParam;&#x0D;&#x0A; this.timestampRequests = opts.timestampRequests;&#x0D;&#x0A; this.readyState = &apos;&apos;;&#x0D;&#x0A; this.agent = opts.agent || false;&#x0D;&#x0A; this.socket = opts.socket;&#x0D;&#x0A; this.enablesXDR = opts.enablesXDR;&#x0D;&#x0A;&#x0D;&#x0A; // SSL options for Node.js client&#x0D;&#x0A; this.pfx = opts.pfx;&#x0D;&#x0A; this.key = opts.key;&#x0D;&#x0A; this.passphrase = opts.passphrase;&#x0D;&#x0A; this.cert = opts.cert;&#x0D;&#x0A; this.ca = opts.ca;&#x0D;&#x0A; this.ciphers = opts.ciphers;&#x0D;&#x0A; this.rejectUnauthorized = opts.rejectUnauthorized;&#x0D;&#x0A;&#x0D;&#x0A; // other options for Node.js client&#x0D;&#x0A; this.extraHeaders = opts.extraHeaders;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mix in `Emitter`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter(Transport.prototype);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Emits an error.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} str&#x0D;&#x0A; * @return {Transport} for chaining&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.onError = function (msg, desc) {&#x0D;&#x0A; var err = new Error(msg);&#x0D;&#x0A; err.type = &apos;TransportError&apos;;&#x0D;&#x0A; err.description = desc;&#x0D;&#x0A; this.emit(&apos;error&apos;, err);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Opens the transport.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.open = function () {&#x0D;&#x0A; if (&apos;closed&apos; == this.readyState || &apos;&apos; == this.readyState) {&#x0D;&#x0A; this.readyState = &apos;opening&apos;;&#x0D;&#x0A; this.doOpen();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Closes the transport.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.close = function () {&#x0D;&#x0A; if (&apos;opening&apos; == this.readyState || &apos;open&apos; == this.readyState) {&#x0D;&#x0A; this.doClose();&#x0D;&#x0A; this.onClose();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sends multiple packets.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Array} packets&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.send = function(packets){&#x0D;&#x0A; if (&apos;open&apos; == this.readyState) {&#x0D;&#x0A; this.write(packets);&#x0D;&#x0A; } else {&#x0D;&#x0A; throw new Error(&apos;Transport not open&apos;);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon open&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.onOpen = function () {&#x0D;&#x0A; this.readyState = &apos;open&apos;;&#x0D;&#x0A; this.writable = true;&#x0D;&#x0A; this.emit(&apos;open&apos;);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called with data.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} data&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.onData = function(data){&#x0D;&#x0A; var packet = parser.decodePacket(data, this.socket.binaryType);&#x0D;&#x0A; this.onPacket(packet);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called with a decoded packet.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.onPacket = function (packet) {&#x0D;&#x0A; this.emit(&apos;packet&apos;, packet);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon close.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Transport.prototype.onClose = function () {&#x0D;&#x0A; this.readyState = &apos;closed&apos;;&#x0D;&#x0A; this.emit(&apos;close&apos;);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;component-emitter&quot;:26,&quot;engine.io-parser&quot;:27}],20:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var XMLHttpRequest = _dereq_(&apos;xmlhttprequest-ssl&apos;);&#x0D;&#x0A;var XHR = _dereq_(&apos;./polling-xhr&apos;);&#x0D;&#x0A;var JSONP = _dereq_(&apos;./polling-jsonp&apos;);&#x0D;&#x0A;var websocket = _dereq_(&apos;./websocket&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Export transports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.polling = polling;&#x0D;&#x0A;exports.websocket = websocket;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Polling transport polymorphic constructor.&#x0D;&#x0A; * Decides on xhr vs jsonp based on feature detection.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function polling(opts){&#x0D;&#x0A; var xhr;&#x0D;&#x0A; var xd = false;&#x0D;&#x0A; var xs = false;&#x0D;&#x0A; var jsonp = false !== opts.jsonp;&#x0D;&#x0A;&#x0D;&#x0A; if (global.location) {&#x0D;&#x0A; var isSSL = &apos;https:&apos; == location.protocol;&#x0D;&#x0A; var port = location.port;&#x0D;&#x0A;&#x0D;&#x0A; // some user agents have empty `location.port`&#x0D;&#x0A; if (!port) {&#x0D;&#x0A; port = isSSL ? 443 : 80;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; xd = opts.hostname != location.hostname || port != opts.port;&#x0D;&#x0A; xs = opts.secure != isSSL;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; opts.xdomain = xd;&#x0D;&#x0A; opts.xscheme = xs;&#x0D;&#x0A; xhr = new XMLHttpRequest(opts);&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;open&apos; in xhr &amp;&amp; !opts.forceJSONP) {&#x0D;&#x0A; return new XHR(opts);&#x0D;&#x0A; } else {&#x0D;&#x0A; if (!jsonp) throw new Error(&apos;JSONP disabled&apos;);&#x0D;&#x0A; return new JSONP(opts);&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;./polling-jsonp&quot;:21,&quot;./polling-xhr&quot;:22,&quot;./websocket&quot;:24,&quot;xmlhttprequest-ssl&quot;:25}],21:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module requirements.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var Polling = _dereq_(&apos;./polling&apos;);&#x0D;&#x0A;var inherit = _dereq_(&apos;component-inherit&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = JSONPPolling;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Cached regular expressions.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var rNewline = /\n/g;&#x0D;&#x0A;var rEscapedNewline = /\\n/g;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Global JSONP callbacks.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var callbacks;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Callbacks count.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var index = 0;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Noop.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function empty () { }&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * JSONP Polling constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} opts.&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function JSONPPolling (opts) {&#x0D;&#x0A; Polling.call(this, opts);&#x0D;&#x0A;&#x0D;&#x0A; this.query = this.query || {};&#x0D;&#x0A;&#x0D;&#x0A; // define global callbacks array if not present&#x0D;&#x0A; // we do this here (lazily) to avoid unneeded global pollution&#x0D;&#x0A; if (!callbacks) {&#x0D;&#x0A; // we need to consider multiple engines in the same page&#x0D;&#x0A; if (!global.___eio) global.___eio = [];&#x0D;&#x0A; callbacks = global.___eio;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // callback identifier&#x0D;&#x0A; this.index = callbacks.length;&#x0D;&#x0A;&#x0D;&#x0A; // add callback to jsonp global&#x0D;&#x0A; var self = this;&#x0D;&#x0A; callbacks.push(function (msg) {&#x0D;&#x0A; self.onData(msg);&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; // append to query string&#x0D;&#x0A; this.query.j = this.index;&#x0D;&#x0A;&#x0D;&#x0A; // prevent spurious errors from being emitted when the window is unloaded&#x0D;&#x0A; if (global.document &amp;&amp; global.addEventListener) {&#x0D;&#x0A; global.addEventListener(&apos;beforeunload&apos;, function () {&#x0D;&#x0A; if (self.script) self.script.onerror = empty;&#x0D;&#x0A; }, false);&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Inherits from Polling.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;inherit(JSONPPolling, Polling);&#x0D;&#x0A;&#x0D;&#x0A;/*&#x0D;&#x0A; * JSONP only supports binary as base64 encoded strings&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;JSONPPolling.prototype.supportsBinary = false;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Closes the socket.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;JSONPPolling.prototype.doClose = function () {&#x0D;&#x0A; if (this.script) {&#x0D;&#x0A; this.script.parentNode.removeChild(this.script);&#x0D;&#x0A; this.script = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (this.form) {&#x0D;&#x0A; this.form.parentNode.removeChild(this.form);&#x0D;&#x0A; this.form = null;&#x0D;&#x0A; this.iframe = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; Polling.prototype.doClose.call(this);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Starts a poll cycle.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;JSONPPolling.prototype.doPoll = function () {&#x0D;&#x0A; var self = this;&#x0D;&#x0A; var script = document.createElement(&apos;script&apos;);&#x0D;&#x0A;&#x0D;&#x0A; if (this.script) {&#x0D;&#x0A; this.script.parentNode.removeChild(this.script);&#x0D;&#x0A; this.script = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; script.async = true;&#x0D;&#x0A; script.src = this.uri();&#x0D;&#x0A; script.onerror = function(e){&#x0D;&#x0A; self.onError(&apos;jsonp poll error&apos;,e);&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; var insertAt = document.getElementsByTagName(&apos;script&apos;)[0];&#x0D;&#x0A; if (insertAt) {&#x0D;&#x0A; insertAt.parentNode.insertBefore(script, insertAt);&#x0D;&#x0A; }&#x0D;&#x0A; else {&#x0D;&#x0A; (document.head || document.body).appendChild(script);&#x0D;&#x0A; }&#x0D;&#x0A; this.script = script;&#x0D;&#x0A;&#x0D;&#x0A; var isUAgecko = &apos;undefined&apos; != typeof navigator &amp;&amp; /gecko/i.test(navigator.userAgent);&#x0D;&#x0A; &#x0D;&#x0A; if (isUAgecko) {&#x0D;&#x0A; setTimeout(function () {&#x0D;&#x0A; var iframe = document.createElement(&apos;iframe&apos;);&#x0D;&#x0A; document.body.appendChild(iframe);&#x0D;&#x0A; document.body.removeChild(iframe);&#x0D;&#x0A; }, 100);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Writes with a hidden iframe.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} data to send&#x0D;&#x0A; * @param {Function} called upon flush.&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;JSONPPolling.prototype.doWrite = function (data, fn) {&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; if (!this.form) {&#x0D;&#x0A; var form = document.createElement(&apos;form&apos;);&#x0D;&#x0A; var area = document.createElement(&apos;textarea&apos;);&#x0D;&#x0A; var id = this.iframeId = &apos;eio_iframe_&apos; + this.index;&#x0D;&#x0A; var iframe;&#x0D;&#x0A;&#x0D;&#x0A; form.className = &apos;socketio&apos;;&#x0D;&#x0A; form.style.position = &apos;absolute&apos;;&#x0D;&#x0A; form.style.top = &apos;-1000px&apos;;&#x0D;&#x0A; form.style.left = &apos;-1000px&apos;;&#x0D;&#x0A; form.target = id;&#x0D;&#x0A; form.method = &apos;POST&apos;;&#x0D;&#x0A; form.setAttribute(&apos;accept-charset&apos;, &apos;utf-8&apos;);&#x0D;&#x0A; area.name = &apos;d&apos;;&#x0D;&#x0A; form.appendChild(area);&#x0D;&#x0A; document.body.appendChild(form);&#x0D;&#x0A;&#x0D;&#x0A; this.form = form;&#x0D;&#x0A; this.area = area;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.form.action = this.uri();&#x0D;&#x0A;&#x0D;&#x0A; function complete () {&#x0D;&#x0A; initIframe();&#x0D;&#x0A; fn();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function initIframe () {&#x0D;&#x0A; if (self.iframe) {&#x0D;&#x0A; try {&#x0D;&#x0A; self.form.removeChild(self.iframe);&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; self.onError(&apos;jsonp polling iframe removal error&apos;, e);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; try {&#x0D;&#x0A; // ie6 dynamic iframes with target=&quot;&quot; support (thanks Chris Lambacher)&#x0D;&#x0A; var html = &apos;&lt;iframe src=&quot;javascript:0&quot; name=&quot;&apos;+ self.iframeId +&apos;&quot;&gt;&apos;;&#x0D;&#x0A; iframe = document.createElement(html);&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; iframe = document.createElement(&apos;iframe&apos;);&#x0D;&#x0A; iframe.name = self.iframeId;&#x0D;&#x0A; iframe.src = &apos;javascript:0&apos;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; iframe.id = self.iframeId;&#x0D;&#x0A;&#x0D;&#x0A; self.form.appendChild(iframe);&#x0D;&#x0A; self.iframe = iframe;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; initIframe();&#x0D;&#x0A;&#x0D;&#x0A; // escape \n to prevent it from being converted into \r\n by some UAs&#x0D;&#x0A; // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side&#x0D;&#x0A; data = data.replace(rEscapedNewline, &apos;\\\n&apos;);&#x0D;&#x0A; this.area.value = data.replace(rNewline, &apos;\\n&apos;);&#x0D;&#x0A;&#x0D;&#x0A; try {&#x0D;&#x0A; this.form.submit();&#x0D;&#x0A; } catch(e) {}&#x0D;&#x0A;&#x0D;&#x0A; if (this.iframe.attachEvent) {&#x0D;&#x0A; this.iframe.onreadystatechange = function(){&#x0D;&#x0A; if (self.iframe.readyState == &apos;complete&apos;) {&#x0D;&#x0A; complete();&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A; } else {&#x0D;&#x0A; this.iframe.onload = complete;&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;./polling&quot;:23,&quot;component-inherit&quot;:13}],22:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/**&#x0D;&#x0A; * Module requirements.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var XMLHttpRequest = _dereq_(&apos;xmlhttprequest-ssl&apos;);&#x0D;&#x0A;var Polling = _dereq_(&apos;./polling&apos;);&#x0D;&#x0A;var Emitter = _dereq_(&apos;component-emitter&apos;);&#x0D;&#x0A;var inherit = _dereq_(&apos;component-inherit&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling-xhr&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = XHR;&#x0D;&#x0A;module.exports.Request = Request;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Empty function&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function empty(){}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * XHR Polling constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} opts&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function XHR(opts){&#x0D;&#x0A; Polling.call(this, opts);&#x0D;&#x0A;&#x0D;&#x0A; if (global.location) {&#x0D;&#x0A; var isSSL = &apos;https:&apos; == location.protocol;&#x0D;&#x0A; var port = location.port;&#x0D;&#x0A;&#x0D;&#x0A; // some user agents have empty `location.port`&#x0D;&#x0A; if (!port) {&#x0D;&#x0A; port = isSSL ? 443 : 80;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.xd = opts.hostname != global.location.hostname ||&#x0D;&#x0A; port != opts.port;&#x0D;&#x0A; this.xs = opts.secure != isSSL;&#x0D;&#x0A; } else {&#x0D;&#x0A; this.extraHeaders = opts.extraHeaders;&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Inherits from Polling.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;inherit(XHR, Polling);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * XHR supports binary&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;XHR.prototype.supportsBinary = true;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Creates a request.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} method&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;XHR.prototype.request = function(opts){&#x0D;&#x0A; opts = opts || {};&#x0D;&#x0A; opts.uri = this.uri();&#x0D;&#x0A; opts.xd = this.xd;&#x0D;&#x0A; opts.xs = this.xs;&#x0D;&#x0A; opts.agent = this.agent || false;&#x0D;&#x0A; opts.supportsBinary = this.supportsBinary;&#x0D;&#x0A; opts.enablesXDR = this.enablesXDR;&#x0D;&#x0A;&#x0D;&#x0A; // SSL options for Node.js client&#x0D;&#x0A; opts.pfx = this.pfx;&#x0D;&#x0A; opts.key = this.key;&#x0D;&#x0A; opts.passphrase = this.passphrase;&#x0D;&#x0A; opts.cert = this.cert;&#x0D;&#x0A; opts.ca = this.ca;&#x0D;&#x0A; opts.ciphers = this.ciphers;&#x0D;&#x0A; opts.rejectUnauthorized = this.rejectUnauthorized;&#x0D;&#x0A;&#x0D;&#x0A; // other options for Node.js client&#x0D;&#x0A; opts.extraHeaders = this.extraHeaders;&#x0D;&#x0A;&#x0D;&#x0A; return new Request(opts);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Sends data.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} data to send.&#x0D;&#x0A; * @param {Function} called upon flush.&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;XHR.prototype.doWrite = function(data, fn){&#x0D;&#x0A; var isBinary = typeof data !== &apos;string&apos; &amp;&amp; data !== undefined;&#x0D;&#x0A; var req = this.request({ method: &apos;POST&apos;, data: data, isBinary: isBinary });&#x0D;&#x0A; var self = this;&#x0D;&#x0A; req.on(&apos;success&apos;, fn);&#x0D;&#x0A; req.on(&apos;error&apos;, function(err){&#x0D;&#x0A; self.onError(&apos;xhr post error&apos;, err);&#x0D;&#x0A; });&#x0D;&#x0A; this.sendXhr = req;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Starts a poll cycle.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;XHR.prototype.doPoll = function(){&#x0D;&#x0A; debug(&apos;xhr poll&apos;);&#x0D;&#x0A; var req = this.request();&#x0D;&#x0A; var self = this;&#x0D;&#x0A; req.on(&apos;data&apos;, function(data){&#x0D;&#x0A; self.onData(data);&#x0D;&#x0A; });&#x0D;&#x0A; req.on(&apos;error&apos;, function(err){&#x0D;&#x0A; self.onError(&apos;xhr poll error&apos;, err);&#x0D;&#x0A; });&#x0D;&#x0A; this.pollXhr = req;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Request constructor&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} options&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Request(opts){&#x0D;&#x0A; this.method = opts.method || &apos;GET&apos;;&#x0D;&#x0A; this.uri = opts.uri;&#x0D;&#x0A; this.xd = !!opts.xd;&#x0D;&#x0A; this.xs = !!opts.xs;&#x0D;&#x0A; this.async = false !== opts.async;&#x0D;&#x0A; this.data = undefined != opts.data ? opts.data : null;&#x0D;&#x0A; this.agent = opts.agent;&#x0D;&#x0A; this.isBinary = opts.isBinary;&#x0D;&#x0A; this.supportsBinary = opts.supportsBinary;&#x0D;&#x0A; this.enablesXDR = opts.enablesXDR;&#x0D;&#x0A;&#x0D;&#x0A; // SSL options for Node.js client&#x0D;&#x0A; this.pfx = opts.pfx;&#x0D;&#x0A; this.key = opts.key;&#x0D;&#x0A; this.passphrase = opts.passphrase;&#x0D;&#x0A; this.cert = opts.cert;&#x0D;&#x0A; this.ca = opts.ca;&#x0D;&#x0A; this.ciphers = opts.ciphers;&#x0D;&#x0A; this.rejectUnauthorized = opts.rejectUnauthorized;&#x0D;&#x0A;&#x0D;&#x0A; // other options for Node.js client&#x0D;&#x0A; this.extraHeaders = opts.extraHeaders;&#x0D;&#x0A;&#x0D;&#x0A; this.create();&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mix in `Emitter`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter(Request.prototype);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Creates the XHR object and sends the request.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.create = function(){&#x0D;&#x0A; var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };&#x0D;&#x0A;&#x0D;&#x0A; // SSL options for Node.js client&#x0D;&#x0A; opts.pfx = this.pfx;&#x0D;&#x0A; opts.key = this.key;&#x0D;&#x0A; opts.passphrase = this.passphrase;&#x0D;&#x0A; opts.cert = this.cert;&#x0D;&#x0A; opts.ca = this.ca;&#x0D;&#x0A; opts.ciphers = this.ciphers;&#x0D;&#x0A; opts.rejectUnauthorized = this.rejectUnauthorized;&#x0D;&#x0A;&#x0D;&#x0A; var xhr = this.xhr = new XMLHttpRequest(opts);&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; try {&#x0D;&#x0A; debug(&apos;xhr open %s: %s&apos;, this.method, this.uri);&#x0D;&#x0A; xhr.open(this.method, this.uri, this.async);&#x0D;&#x0A; try {&#x0D;&#x0A; if (this.extraHeaders) {&#x0D;&#x0A; xhr.setDisableHeaderCheck(true);&#x0D;&#x0A; for (var i in this.extraHeaders) {&#x0D;&#x0A; if (this.extraHeaders.hasOwnProperty(i)) {&#x0D;&#x0A; xhr.setRequestHeader(i, this.extraHeaders[i]);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; } catch (e) {}&#x0D;&#x0A; if (this.supportsBinary) {&#x0D;&#x0A; // This has to be done after open because Firefox is stupid&#x0D;&#x0A; // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension&#x0D;&#x0A; xhr.responseType = &apos;arraybuffer&apos;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;POST&apos; == this.method) {&#x0D;&#x0A; try {&#x0D;&#x0A; if (this.isBinary) {&#x0D;&#x0A; xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/octet-stream&apos;);&#x0D;&#x0A; } else {&#x0D;&#x0A; xhr.setRequestHeader(&apos;Content-type&apos;, &apos;text/plain;charset=UTF-8&apos;);&#x0D;&#x0A; }&#x0D;&#x0A; } catch (e) {}&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // ie6 check&#x0D;&#x0A; if (&apos;withCredentials&apos; in xhr) {&#x0D;&#x0A; xhr.withCredentials = true;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (this.hasXDR()) {&#x0D;&#x0A; xhr.onload = function(){&#x0D;&#x0A; self.onLoad();&#x0D;&#x0A; };&#x0D;&#x0A; xhr.onerror = function(){&#x0D;&#x0A; self.onError(xhr.responseText);&#x0D;&#x0A; };&#x0D;&#x0A; } else {&#x0D;&#x0A; xhr.onreadystatechange = function(){&#x0D;&#x0A; if (4 != xhr.readyState) return;&#x0D;&#x0A; if (200 == xhr.status || 1223 == xhr.status) {&#x0D;&#x0A; self.onLoad();&#x0D;&#x0A; } else {&#x0D;&#x0A; // make sure the `error` event handler that&apos;s user-set&#x0D;&#x0A; // does not throw in the same tick and gets caught here&#x0D;&#x0A; setTimeout(function(){&#x0D;&#x0A; self.onError(xhr.status);&#x0D;&#x0A; }, 0);&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;xhr data %s&apos;, this.data);&#x0D;&#x0A; xhr.send(this.data);&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; // Need to defer since .create() is called directly fhrom the constructor&#x0D;&#x0A; // and thus the &apos;error&apos; event can only be only bound *after* this exception&#x0D;&#x0A; // occurs. Therefore, also, we cannot throw here at all.&#x0D;&#x0A; setTimeout(function() {&#x0D;&#x0A; self.onError(e);&#x0D;&#x0A; }, 0);&#x0D;&#x0A; return;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (global.document) {&#x0D;&#x0A; this.index = Request.requestsCount++;&#x0D;&#x0A; Request.requests[this.index] = this;&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon successful response.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.onSuccess = function(){&#x0D;&#x0A; this.emit(&apos;success&apos;);&#x0D;&#x0A; this.cleanup();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called if we have data.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.onData = function(data){&#x0D;&#x0A; this.emit(&apos;data&apos;, data);&#x0D;&#x0A; this.onSuccess();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon error.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.onError = function(err){&#x0D;&#x0A; this.emit(&apos;error&apos;, err);&#x0D;&#x0A; this.cleanup(true);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Cleans up house.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.cleanup = function(fromError){&#x0D;&#x0A; if (&apos;undefined&apos; == typeof this.xhr || null === this.xhr) {&#x0D;&#x0A; return;&#x0D;&#x0A; }&#x0D;&#x0A; // xmlhttprequest&#x0D;&#x0A; if (this.hasXDR()) {&#x0D;&#x0A; this.xhr.onload = this.xhr.onerror = empty;&#x0D;&#x0A; } else {&#x0D;&#x0A; this.xhr.onreadystatechange = empty;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (fromError) {&#x0D;&#x0A; try {&#x0D;&#x0A; this.xhr.abort();&#x0D;&#x0A; } catch(e) {}&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (global.document) {&#x0D;&#x0A; delete Request.requests[this.index];&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.xhr = null;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon load.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.onLoad = function(){&#x0D;&#x0A; var data;&#x0D;&#x0A; try {&#x0D;&#x0A; var contentType;&#x0D;&#x0A; try {&#x0D;&#x0A; contentType = this.xhr.getResponseHeader(&apos;Content-Type&apos;).split(&apos;;&apos;)[0];&#x0D;&#x0A; } catch (e) {}&#x0D;&#x0A; if (contentType === &apos;application/octet-stream&apos;) {&#x0D;&#x0A; data = this.xhr.response;&#x0D;&#x0A; } else {&#x0D;&#x0A; if (!this.supportsBinary) {&#x0D;&#x0A; data = this.xhr.responseText;&#x0D;&#x0A; } else {&#x0D;&#x0A; try {&#x0D;&#x0A; data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; var ui8Arr = new Uint8Array(this.xhr.response);&#x0D;&#x0A; var dataArray = [];&#x0D;&#x0A; for (var idx = 0, length = ui8Arr.length; idx &lt; length; idx++) {&#x0D;&#x0A; dataArray.push(ui8Arr[idx]);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; data = String.fromCharCode.apply(null, dataArray);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; this.onError(e);&#x0D;&#x0A; }&#x0D;&#x0A; if (null != data) {&#x0D;&#x0A; this.onData(data);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if it has XDomainRequest.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.hasXDR = function(){&#x0D;&#x0A; return &apos;undefined&apos; !== typeof global.XDomainRequest &amp;&amp; !this.xs &amp;&amp; this.enablesXDR;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Aborts the request.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Request.prototype.abort = function(){&#x0D;&#x0A; this.cleanup();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Aborts pending requests when unloading the window. This is needed to prevent&#x0D;&#x0A; * memory leaks (e.g. when using IE) and to ensure that no spurious error is&#x0D;&#x0A; * emitted.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;if (global.document) {&#x0D;&#x0A; Request.requestsCount = 0;&#x0D;&#x0A; Request.requests = {};&#x0D;&#x0A; if (global.attachEvent) {&#x0D;&#x0A; global.attachEvent(&apos;onunload&apos;, unloadHandler);&#x0D;&#x0A; } else if (global.addEventListener) {&#x0D;&#x0A; global.addEventListener(&apos;beforeunload&apos;, unloadHandler, false);&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;function unloadHandler() {&#x0D;&#x0A; for (var i in Request.requests) {&#x0D;&#x0A; if (Request.requests.hasOwnProperty(i)) {&#x0D;&#x0A; Request.requests[i].abort();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;./polling&quot;:23,&quot;component-emitter&quot;:26,&quot;component-inherit&quot;:13,&quot;debug&quot;:14,&quot;xmlhttprequest-ssl&quot;:25}],23:[function(_dereq_,module,exports){&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var Transport = _dereq_(&apos;../transport&apos;);&#x0D;&#x0A;var parseqs = _dereq_(&apos;parseqs&apos;);&#x0D;&#x0A;var parser = _dereq_(&apos;engine.io-parser&apos;);&#x0D;&#x0A;var inherit = _dereq_(&apos;component-inherit&apos;);&#x0D;&#x0A;var yeast = _dereq_(&apos;yeast&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:polling&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Polling;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Is XHR2 supported?&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var hasXHR2 = (function() {&#x0D;&#x0A; var XMLHttpRequest = _dereq_(&apos;xmlhttprequest-ssl&apos;);&#x0D;&#x0A; var xhr = new XMLHttpRequest({ xdomain: false });&#x0D;&#x0A; return null != xhr.responseType;&#x0D;&#x0A;})();&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Polling interface.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} opts&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Polling(opts){&#x0D;&#x0A; var forceBase64 = (opts &amp;&amp; opts.forceBase64);&#x0D;&#x0A; if (!hasXHR2 || forceBase64) {&#x0D;&#x0A; this.supportsBinary = false;&#x0D;&#x0A; }&#x0D;&#x0A; Transport.call(this, opts);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Inherits from Transport.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;inherit(Polling, Transport);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Transport name.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.name = &apos;polling&apos;;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Opens the socket (triggers polling). We write a PING message to determine&#x0D;&#x0A; * when the transport is open.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.doOpen = function(){&#x0D;&#x0A; this.poll();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Pauses polling.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Function} callback upon buffers are flushed and transport is paused&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.pause = function(onPause){&#x0D;&#x0A; var pending = 0;&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; this.readyState = &apos;pausing&apos;;&#x0D;&#x0A;&#x0D;&#x0A; function pause(){&#x0D;&#x0A; debug(&apos;paused&apos;);&#x0D;&#x0A; self.readyState = &apos;paused&apos;;&#x0D;&#x0A; onPause();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (this.polling || !this.writable) {&#x0D;&#x0A; var total = 0;&#x0D;&#x0A;&#x0D;&#x0A; if (this.polling) {&#x0D;&#x0A; debug(&apos;we are currently polling - waiting to pause&apos;);&#x0D;&#x0A; total++;&#x0D;&#x0A; this.once(&apos;pollComplete&apos;, function(){&#x0D;&#x0A; debug(&apos;pre-pause polling complete&apos;);&#x0D;&#x0A; --total || pause();&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (!this.writable) {&#x0D;&#x0A; debug(&apos;we are currently writing - waiting to pause&apos;);&#x0D;&#x0A; total++;&#x0D;&#x0A; this.once(&apos;drain&apos;, function(){&#x0D;&#x0A; debug(&apos;pre-pause writing complete&apos;);&#x0D;&#x0A; --total || pause();&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A; } else {&#x0D;&#x0A; pause();&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Starts polling cycle.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.poll = function(){&#x0D;&#x0A; debug(&apos;polling&apos;);&#x0D;&#x0A; this.polling = true;&#x0D;&#x0A; this.doPoll();&#x0D;&#x0A; this.emit(&apos;poll&apos;);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Overloads onData to detect payloads.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.onData = function(data){&#x0D;&#x0A; var self = this;&#x0D;&#x0A; debug(&apos;polling got data %s&apos;, data);&#x0D;&#x0A; var callback = function(packet, index, total) {&#x0D;&#x0A; // if its the first message we consider the transport open&#x0D;&#x0A; if (&apos;opening&apos; == self.readyState) {&#x0D;&#x0A; self.onOpen();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // if its a close packet, we close the ongoing requests&#x0D;&#x0A; if (&apos;close&apos; == packet.type) {&#x0D;&#x0A; self.onClose();&#x0D;&#x0A; return false;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // otherwise bypass onData and handle the message&#x0D;&#x0A; self.onPacket(packet);&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // decode payload&#x0D;&#x0A; parser.decodePayload(data, this.socket.binaryType, callback);&#x0D;&#x0A;&#x0D;&#x0A; // if an event did not trigger closing&#x0D;&#x0A; if (&apos;closed&apos; != this.readyState) {&#x0D;&#x0A; // if we got data we&apos;re not polling&#x0D;&#x0A; this.polling = false;&#x0D;&#x0A; this.emit(&apos;pollComplete&apos;);&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;open&apos; == this.readyState) {&#x0D;&#x0A; this.poll();&#x0D;&#x0A; } else {&#x0D;&#x0A; debug(&apos;ignoring poll - transport state &quot;%s&quot;&apos;, this.readyState);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * For polling, send a close packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.doClose = function(){&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; function close(){&#x0D;&#x0A; debug(&apos;writing close packet&apos;);&#x0D;&#x0A; self.write([{ type: &apos;close&apos; }]);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;open&apos; == this.readyState) {&#x0D;&#x0A; debug(&apos;transport open - closing&apos;);&#x0D;&#x0A; close();&#x0D;&#x0A; } else {&#x0D;&#x0A; // in case we&apos;re trying to close while&#x0D;&#x0A; // handshaking is in progress (GH-164)&#x0D;&#x0A; debug(&apos;transport not open - deferring close&apos;);&#x0D;&#x0A; this.once(&apos;open&apos;, close);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Writes a packets payload.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Array} data packets&#x0D;&#x0A; * @param {Function} drain callback&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.write = function(packets){&#x0D;&#x0A; var self = this;&#x0D;&#x0A; this.writable = false;&#x0D;&#x0A; var callbackfn = function() {&#x0D;&#x0A; self.writable = true;&#x0D;&#x0A; self.emit(&apos;drain&apos;);&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; var self = this;&#x0D;&#x0A; parser.encodePayload(packets, this.supportsBinary, function(data) {&#x0D;&#x0A; self.doWrite(data, callbackfn);&#x0D;&#x0A; });&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Generates uri for connection.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Polling.prototype.uri = function(){&#x0D;&#x0A; var query = this.query || {};&#x0D;&#x0A; var schema = this.secure ? &apos;https&apos; : &apos;http&apos;;&#x0D;&#x0A; var port = &apos;&apos;;&#x0D;&#x0A;&#x0D;&#x0A; // cache busting is forced&#x0D;&#x0A; if (false !== this.timestampRequests) {&#x0D;&#x0A; query[this.timestampParam] = yeast();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (!this.supportsBinary &amp;&amp; !query.sid) {&#x0D;&#x0A; query.b64 = 1;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; query = parseqs.encode(query);&#x0D;&#x0A;&#x0D;&#x0A; // avoid port if default for schema&#x0D;&#x0A; if (this.port &amp;&amp; ((&apos;https&apos; == schema &amp;&amp; this.port != 443) ||&#x0D;&#x0A; (&apos;http&apos; == schema &amp;&amp; this.port != 80))) {&#x0D;&#x0A; port = &apos;:&apos; + this.port;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // prepend ? to query&#x0D;&#x0A; if (query.length) {&#x0D;&#x0A; query = &apos;?&apos; + query;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var ipv6 = this.hostname.indexOf(&apos;:&apos;) !== -1;&#x0D;&#x0A; return schema + &apos;://&apos; + (ipv6 ? &apos;[&apos; + this.hostname + &apos;]&apos; : this.hostname) + port + this.path + query;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;../transport&quot;:19,&quot;component-inherit&quot;:13,&quot;debug&quot;:14,&quot;engine.io-parser&quot;:27,&quot;parseqs&quot;:37,&quot;xmlhttprequest-ssl&quot;:25,&quot;yeast&quot;:45}],24:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var Transport = _dereq_(&apos;../transport&apos;);&#x0D;&#x0A;var parser = _dereq_(&apos;engine.io-parser&apos;);&#x0D;&#x0A;var parseqs = _dereq_(&apos;parseqs&apos;);&#x0D;&#x0A;var inherit = _dereq_(&apos;component-inherit&apos;);&#x0D;&#x0A;var yeast = _dereq_(&apos;yeast&apos;);&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;engine.io-client:websocket&apos;);&#x0D;&#x0A;var BrowserWebSocket = global.WebSocket || global.MozWebSocket;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Get either the `WebSocket` or `MozWebSocket` globals&#x0D;&#x0A; * in the browser or try to resolve WebSocket-compatible&#x0D;&#x0A; * interface exposed by `ws` for Node-like environment.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var WebSocket = BrowserWebSocket;&#x0D;&#x0A;if (!WebSocket &amp;&amp; typeof window === &apos;undefined&apos;) {&#x0D;&#x0A; try {&#x0D;&#x0A; WebSocket = _dereq_(&apos;ws&apos;);&#x0D;&#x0A; } catch (e) { }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = WS;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * WebSocket transport constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @api {Object} connection options&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function WS(opts){&#x0D;&#x0A; var forceBase64 = (opts &amp;&amp; opts.forceBase64);&#x0D;&#x0A; if (forceBase64) {&#x0D;&#x0A; this.supportsBinary = false;&#x0D;&#x0A; }&#x0D;&#x0A; this.perMessageDeflate = opts.perMessageDeflate;&#x0D;&#x0A; Transport.call(this, opts);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Inherits from Transport.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;inherit(WS, Transport);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Transport name.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.name = &apos;websocket&apos;;&#x0D;&#x0A;&#x0D;&#x0A;/*&#x0D;&#x0A; * WebSockets support binary&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.supportsBinary = true;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Opens socket.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.doOpen = function(){&#x0D;&#x0A; if (!this.check()) {&#x0D;&#x0A; // let probe timeout&#x0D;&#x0A; return;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var self = this;&#x0D;&#x0A; var uri = this.uri();&#x0D;&#x0A; var protocols = void(0);&#x0D;&#x0A; var opts = {&#x0D;&#x0A; agent: this.agent,&#x0D;&#x0A; perMessageDeflate: this.perMessageDeflate&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // SSL options for Node.js client&#x0D;&#x0A; opts.pfx = this.pfx;&#x0D;&#x0A; opts.key = this.key;&#x0D;&#x0A; opts.passphrase = this.passphrase;&#x0D;&#x0A; opts.cert = this.cert;&#x0D;&#x0A; opts.ca = this.ca;&#x0D;&#x0A; opts.ciphers = this.ciphers;&#x0D;&#x0A; opts.rejectUnauthorized = this.rejectUnauthorized;&#x0D;&#x0A; if (this.extraHeaders) {&#x0D;&#x0A; opts.headers = this.extraHeaders;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);&#x0D;&#x0A;&#x0D;&#x0A; if (this.ws.binaryType === undefined) {&#x0D;&#x0A; this.supportsBinary = false;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (this.ws.supports &amp;&amp; this.ws.supports.binary) {&#x0D;&#x0A; this.supportsBinary = true;&#x0D;&#x0A; this.ws.binaryType = &apos;buffer&apos;;&#x0D;&#x0A; } else {&#x0D;&#x0A; this.ws.binaryType = &apos;arraybuffer&apos;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; this.addEventListeners();&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Adds event listeners to the socket&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.addEventListeners = function(){&#x0D;&#x0A; var self = this;&#x0D;&#x0A;&#x0D;&#x0A; this.ws.onopen = function(){&#x0D;&#x0A; self.onOpen();&#x0D;&#x0A; };&#x0D;&#x0A; this.ws.onclose = function(){&#x0D;&#x0A; self.onClose();&#x0D;&#x0A; };&#x0D;&#x0A; this.ws.onmessage = function(ev){&#x0D;&#x0A; self.onData(ev.data);&#x0D;&#x0A; };&#x0D;&#x0A; this.ws.onerror = function(e){&#x0D;&#x0A; self.onError(&apos;websocket error&apos;, e);&#x0D;&#x0A; };&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Override `onData` to use a timer on iOS.&#x0D;&#x0A; * See: https://gist.github.com/mloughran/2052006&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;if (&apos;undefined&apos; != typeof navigator&#x0D;&#x0A; &amp;&amp; /iPad|iPhone|iPod/i.test(navigator.userAgent)) {&#x0D;&#x0A; WS.prototype.onData = function(data){&#x0D;&#x0A; var self = this;&#x0D;&#x0A; setTimeout(function(){&#x0D;&#x0A; Transport.prototype.onData.call(self, data);&#x0D;&#x0A; }, 0);&#x0D;&#x0A; };&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Writes data to socket.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Array} array of packets.&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.write = function(packets){&#x0D;&#x0A; var self = this;&#x0D;&#x0A; this.writable = false;&#x0D;&#x0A;&#x0D;&#x0A; // encodePacket efficient as it uses WS framing&#x0D;&#x0A; // no need for encodePayload&#x0D;&#x0A; var total = packets.length;&#x0D;&#x0A; for (var i = 0, l = total; i &lt; l; i++) {&#x0D;&#x0A; (function(packet) {&#x0D;&#x0A; parser.encodePacket(packet, self.supportsBinary, function(data) {&#x0D;&#x0A; if (!BrowserWebSocket) {&#x0D;&#x0A; // always create a new object (GH-437)&#x0D;&#x0A; var opts = {};&#x0D;&#x0A; if (packet.options) {&#x0D;&#x0A; opts.compress = packet.options.compress;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (self.perMessageDeflate) {&#x0D;&#x0A; var len = &apos;string&apos; == typeof data ? global.Buffer.byteLength(data) : data.length;&#x0D;&#x0A; if (len &lt; self.perMessageDeflate.threshold) {&#x0D;&#x0A; opts.compress = false;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; //Sometimes the websocket has already been closed but the browser didn&apos;t&#x0D;&#x0A; //have a chance of informing us about it yet, in that case send will&#x0D;&#x0A; //throw an error&#x0D;&#x0A; try {&#x0D;&#x0A; if (BrowserWebSocket) {&#x0D;&#x0A; // TypeError is thrown when passing the second argument on Safari&#x0D;&#x0A; self.ws.send(data);&#x0D;&#x0A; } else {&#x0D;&#x0A; self.ws.send(data, opts);&#x0D;&#x0A; }&#x0D;&#x0A; } catch (e){&#x0D;&#x0A; debug(&apos;websocket closed before onclose event&apos;);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; --total || done();&#x0D;&#x0A; });&#x0D;&#x0A; })(packets[i]);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function done(){&#x0D;&#x0A; self.emit(&apos;flush&apos;);&#x0D;&#x0A;&#x0D;&#x0A; // fake drain&#x0D;&#x0A; // defer to next tick to allow Socket to clear writeBuffer&#x0D;&#x0A; setTimeout(function(){&#x0D;&#x0A; self.writable = true;&#x0D;&#x0A; self.emit(&apos;drain&apos;);&#x0D;&#x0A; }, 0);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Called upon close&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.onClose = function(){&#x0D;&#x0A; Transport.prototype.onClose.call(this);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Closes socket.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.doClose = function(){&#x0D;&#x0A; if (typeof this.ws !== &apos;undefined&apos;) {&#x0D;&#x0A; this.ws.close();&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Generates uri for connection.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.uri = function(){&#x0D;&#x0A; var query = this.query || {};&#x0D;&#x0A; var schema = this.secure ? &apos;wss&apos; : &apos;ws&apos;;&#x0D;&#x0A; var port = &apos;&apos;;&#x0D;&#x0A;&#x0D;&#x0A; // avoid port if default for schema&#x0D;&#x0A; if (this.port &amp;&amp; ((&apos;wss&apos; == schema &amp;&amp; this.port != 443)&#x0D;&#x0A; || (&apos;ws&apos; == schema &amp;&amp; this.port != 80))) {&#x0D;&#x0A; port = &apos;:&apos; + this.port;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // append timestamp to URI&#x0D;&#x0A; if (this.timestampRequests) {&#x0D;&#x0A; query[this.timestampParam] = yeast();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // communicate binary support capabilities&#x0D;&#x0A; if (!this.supportsBinary) {&#x0D;&#x0A; query.b64 = 1;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; query = parseqs.encode(query);&#x0D;&#x0A;&#x0D;&#x0A; // prepend ? to query&#x0D;&#x0A; if (query.length) {&#x0D;&#x0A; query = &apos;?&apos; + query;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var ipv6 = this.hostname.indexOf(&apos;:&apos;) !== -1;&#x0D;&#x0A; return schema + &apos;://&apos; + (ipv6 ? &apos;[&apos; + this.hostname + &apos;]&apos; : this.hostname) + port + this.path + query;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Feature detection for WebSocket.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Boolean} whether this transport is available.&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;WS.prototype.check = function(){&#x0D;&#x0A; return !!WebSocket &amp;&amp; !(&apos;__initialize&apos; in WebSocket &amp;&amp; this.name === WS.prototype.name);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;../transport&quot;:19,&quot;component-inherit&quot;:13,&quot;debug&quot;:14,&quot;engine.io-parser&quot;:27,&quot;parseqs&quot;:37,&quot;ws&quot;:undefined,&quot;yeast&quot;:45}],25:[function(_dereq_,module,exports){&#x0D;&#x0A;// browser shim for xmlhttprequest module&#x0D;&#x0A;var hasCORS = _dereq_(&apos;has-cors&apos;);&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function(opts) {&#x0D;&#x0A; var xdomain = opts.xdomain;&#x0D;&#x0A;&#x0D;&#x0A; // scheme must be same when usign XDomainRequest&#x0D;&#x0A; // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx&#x0D;&#x0A; var xscheme = opts.xscheme;&#x0D;&#x0A;&#x0D;&#x0A; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.&#x0D;&#x0A; // https://github.com/Automattic/engine.io-client/pull/217&#x0D;&#x0A; var enablesXDR = opts.enablesXDR;&#x0D;&#x0A;&#x0D;&#x0A; // XMLHttpRequest can be disabled on IE&#x0D;&#x0A; try {&#x0D;&#x0A; if (&apos;undefined&apos; != typeof XMLHttpRequest &amp;&amp; (!xdomain || hasCORS)) {&#x0D;&#x0A; return new XMLHttpRequest();&#x0D;&#x0A; }&#x0D;&#x0A; } catch (e) { }&#x0D;&#x0A;&#x0D;&#x0A; // Use XDomainRequest for IE8 if enablesXDR is true&#x0D;&#x0A; // because loading bar keeps flashing when using jsonp-polling&#x0D;&#x0A; // https://github.com/yujiosaka/socke.io-ie8-loading-example&#x0D;&#x0A; try {&#x0D;&#x0A; if (&apos;undefined&apos; != typeof XDomainRequest &amp;&amp; !xscheme &amp;&amp; enablesXDR) {&#x0D;&#x0A; return new XDomainRequest();&#x0D;&#x0A; }&#x0D;&#x0A; } catch (e) { }&#x0D;&#x0A;&#x0D;&#x0A; if (!xdomain) {&#x0D;&#x0A; try {&#x0D;&#x0A; return new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#x0D;&#x0A; } catch(e) { }&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;has-cors&quot;:31}],26:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Expose `Emitter`.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Emitter;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Initialize a new `Emitter`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Emitter(obj) {&#x0D;&#x0A; if (obj) return mixin(obj);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mixin the emitter properties.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} obj&#x0D;&#x0A; * @return {Object}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function mixin(obj) {&#x0D;&#x0A; for (var key in Emitter.prototype) {&#x0D;&#x0A; obj[key] = Emitter.prototype[key];&#x0D;&#x0A; }&#x0D;&#x0A; return obj;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Listen on the given `event` with `fn`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Function} fn&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.on =&#x0D;&#x0A;Emitter.prototype.addEventListener = function(event, fn){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A; (this._callbacks[event] = this._callbacks[event] || [])&#x0D;&#x0A; .push(fn);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Adds an `event` listener that will be invoked a single&#x0D;&#x0A; * time then automatically removed.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Function} fn&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.once = function(event, fn){&#x0D;&#x0A; var self = this;&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A;&#x0D;&#x0A; function on() {&#x0D;&#x0A; self.off(event, on);&#x0D;&#x0A; fn.apply(this, arguments);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; on.fn = fn;&#x0D;&#x0A; this.on(event, on);&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Remove the given callback for `event` or all&#x0D;&#x0A; * registered callbacks.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Function} fn&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.off =&#x0D;&#x0A;Emitter.prototype.removeListener =&#x0D;&#x0A;Emitter.prototype.removeAllListeners =&#x0D;&#x0A;Emitter.prototype.removeEventListener = function(event, fn){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A;&#x0D;&#x0A; // all&#x0D;&#x0A; if (0 == arguments.length) {&#x0D;&#x0A; this._callbacks = {};&#x0D;&#x0A; return this;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // specific event&#x0D;&#x0A; var callbacks = this._callbacks[event];&#x0D;&#x0A; if (!callbacks) return this;&#x0D;&#x0A;&#x0D;&#x0A; // remove all handlers&#x0D;&#x0A; if (1 == arguments.length) {&#x0D;&#x0A; delete this._callbacks[event];&#x0D;&#x0A; return this;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // remove specific handler&#x0D;&#x0A; var cb;&#x0D;&#x0A; for (var i = 0; i &lt; callbacks.length; i++) {&#x0D;&#x0A; cb = callbacks[i];&#x0D;&#x0A; if (cb === fn || cb.fn === fn) {&#x0D;&#x0A; callbacks.splice(i, 1);&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Emit `event` with the given args.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @param {Mixed} ...&#x0D;&#x0A; * @return {Emitter}&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.emit = function(event){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A; var args = [].slice.call(arguments, 1)&#x0D;&#x0A; , callbacks = this._callbacks[event];&#x0D;&#x0A;&#x0D;&#x0A; if (callbacks) {&#x0D;&#x0A; callbacks = callbacks.slice(0);&#x0D;&#x0A; for (var i = 0, len = callbacks.length; i &lt; len; ++i) {&#x0D;&#x0A; callbacks[i].apply(this, args);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return this;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Return array of callbacks for `event`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @return {Array}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.listeners = function(event){&#x0D;&#x0A; this._callbacks = this._callbacks || {};&#x0D;&#x0A; return this._callbacks[event] || [];&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if this emitter has `event` handlers.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} event&#x0D;&#x0A; * @return {Boolean}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter.prototype.hasListeners = function(event){&#x0D;&#x0A; return !! this.listeners(event).length;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],27:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var keys = _dereq_(&apos;./keys&apos;);&#x0D;&#x0A;var hasBinary = _dereq_(&apos;has-binary&apos;);&#x0D;&#x0A;var sliceBuffer = _dereq_(&apos;arraybuffer.slice&apos;);&#x0D;&#x0A;var base64encoder = _dereq_(&apos;base64-arraybuffer&apos;);&#x0D;&#x0A;var after = _dereq_(&apos;after&apos;);&#x0D;&#x0A;var utf8 = _dereq_(&apos;utf8&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if we are running an android browser. That requires us to use&#x0D;&#x0A; * ArrayBuffer with polling transports...&#x0D;&#x0A; *&#x0D;&#x0A; * http://ghinda.net/jpeg-blob-ajax-android/&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var isAndroid = navigator.userAgent.match(/Android/i);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Check if we are running in PhantomJS.&#x0D;&#x0A; * Uploading a Blob with PhantomJS does not work correctly, as reported here:&#x0D;&#x0A; * https://github.com/ariya/phantomjs/issues/11395&#x0D;&#x0A; * @type boolean&#x0D;&#x0A; */&#x0D;&#x0A;var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * When true, avoids using Blobs to encode payloads.&#x0D;&#x0A; * @type boolean&#x0D;&#x0A; */&#x0D;&#x0A;var dontSendBlobs = isAndroid || isPhantomJS;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Current protocol version.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.protocol = 3;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet types.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var packets = exports.packets = {&#x0D;&#x0A; open: 0 // non-ws&#x0D;&#x0A; , close: 1 // non-ws&#x0D;&#x0A; , ping: 2&#x0D;&#x0A; , pong: 3&#x0D;&#x0A; , message: 4&#x0D;&#x0A; , upgrade: 5&#x0D;&#x0A; , noop: 6&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;var packetslist = keys(packets);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Premade error packet.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var err = { type: &apos;error&apos;, data: &apos;parser error&apos; };&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Create a blob api even for blob builder when vendor prefixes exist&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var Blob = _dereq_(&apos;blob&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encodes a packet.&#x0D;&#x0A; *&#x0D;&#x0A; * &lt;packet type id&gt; [ &lt;data&gt; ]&#x0D;&#x0A; *&#x0D;&#x0A; * Example:&#x0D;&#x0A; *&#x0D;&#x0A; * 5hello world&#x0D;&#x0A; * 3&#x0D;&#x0A; * 4&#x0D;&#x0A; *&#x0D;&#x0A; * Binary is encoded in an identical principle&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {&#x0D;&#x0A; if (&apos;function&apos; == typeof supportsBinary) {&#x0D;&#x0A; callback = supportsBinary;&#x0D;&#x0A; supportsBinary = false;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;function&apos; == typeof utf8encode) {&#x0D;&#x0A; callback = utf8encode;&#x0D;&#x0A; utf8encode = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var data = (packet.data === undefined)&#x0D;&#x0A; ? undefined&#x0D;&#x0A; : packet.data.buffer || packet.data;&#x0D;&#x0A;&#x0D;&#x0A; if (global.ArrayBuffer &amp;&amp; data instanceof ArrayBuffer) {&#x0D;&#x0A; return encodeArrayBuffer(packet, supportsBinary, callback);&#x0D;&#x0A; } else if (Blob &amp;&amp; data instanceof global.Blob) {&#x0D;&#x0A; return encodeBlob(packet, supportsBinary, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // might be an object with { base64: true, data: dataAsBase64String }&#x0D;&#x0A; if (data &amp;&amp; data.base64) {&#x0D;&#x0A; return encodeBase64Object(packet, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // Sending data as a utf-8 string&#x0D;&#x0A; var encoded = packets[packet.type];&#x0D;&#x0A;&#x0D;&#x0A; // data fragment is optional&#x0D;&#x0A; if (undefined !== packet.data) {&#x0D;&#x0A; encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return callback(&apos;&apos; + encoded);&#x0D;&#x0A;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;function encodeBase64Object(packet, callback) {&#x0D;&#x0A; // packet data is an object { base64: true, data: dataAsBase64String }&#x0D;&#x0A; var message = &apos;b&apos; + exports.packets[packet.type] + packet.data.data;&#x0D;&#x0A; return callback(message);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encode packet helpers for binary types&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function encodeArrayBuffer(packet, supportsBinary, callback) {&#x0D;&#x0A; if (!supportsBinary) {&#x0D;&#x0A; return exports.encodeBase64Packet(packet, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var data = packet.data;&#x0D;&#x0A; var contentArray = new Uint8Array(data);&#x0D;&#x0A; var resultBuffer = new Uint8Array(1 + data.byteLength);&#x0D;&#x0A;&#x0D;&#x0A; resultBuffer[0] = packets[packet.type];&#x0D;&#x0A; for (var i = 0; i &lt; contentArray.length; i++) {&#x0D;&#x0A; resultBuffer[i+1] = contentArray[i];&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return callback(resultBuffer.buffer);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {&#x0D;&#x0A; if (!supportsBinary) {&#x0D;&#x0A; return exports.encodeBase64Packet(packet, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var fr = new FileReader();&#x0D;&#x0A; fr.onload = function() {&#x0D;&#x0A; packet.data = fr.result;&#x0D;&#x0A; exports.encodePacket(packet, supportsBinary, true, callback);&#x0D;&#x0A; };&#x0D;&#x0A; return fr.readAsArrayBuffer(packet.data);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;function encodeBlob(packet, supportsBinary, callback) {&#x0D;&#x0A; if (!supportsBinary) {&#x0D;&#x0A; return exports.encodeBase64Packet(packet, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (dontSendBlobs) {&#x0D;&#x0A; return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var length = new Uint8Array(1);&#x0D;&#x0A; length[0] = packets[packet.type];&#x0D;&#x0A; var blob = new Blob([length.buffer, packet.data]);&#x0D;&#x0A;&#x0D;&#x0A; return callback(blob);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encodes a packet with binary data in a base64 string&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet, has `type` and `data`&#x0D;&#x0A; * @return {String} base64 encoded message&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.encodeBase64Packet = function(packet, callback) {&#x0D;&#x0A; var message = &apos;b&apos; + exports.packets[packet.type];&#x0D;&#x0A; if (Blob &amp;&amp; packet.data instanceof global.Blob) {&#x0D;&#x0A; var fr = new FileReader();&#x0D;&#x0A; fr.onload = function() {&#x0D;&#x0A; var b64 = fr.result.split(&apos;,&apos;)[1];&#x0D;&#x0A; callback(message + b64);&#x0D;&#x0A; };&#x0D;&#x0A; return fr.readAsDataURL(packet.data);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var b64data;&#x0D;&#x0A; try {&#x0D;&#x0A; b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; // iPhone Safari doesn&apos;t let you apply with typed arrays&#x0D;&#x0A; var typed = new Uint8Array(packet.data);&#x0D;&#x0A; var basic = new Array(typed.length);&#x0D;&#x0A; for (var i = 0; i &lt; typed.length; i++) {&#x0D;&#x0A; basic[i] = typed[i];&#x0D;&#x0A; }&#x0D;&#x0A; b64data = String.fromCharCode.apply(null, basic);&#x0D;&#x0A; }&#x0D;&#x0A; message += global.btoa(b64data);&#x0D;&#x0A; return callback(message);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Decodes a packet. Changes format to Blob if requested.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Object} with `type` and `data` (if any)&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.decodePacket = function (data, binaryType, utf8decode) {&#x0D;&#x0A; // String data&#x0D;&#x0A; if (typeof data == &apos;string&apos; || data === undefined) {&#x0D;&#x0A; if (data.charAt(0) == &apos;b&apos;) {&#x0D;&#x0A; return exports.decodeBase64Packet(data.substr(1), binaryType);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (utf8decode) {&#x0D;&#x0A; try {&#x0D;&#x0A; data = utf8.decode(data);&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; return err;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; var type = data.charAt(0);&#x0D;&#x0A;&#x0D;&#x0A; if (Number(type) != type || !packetslist[type]) {&#x0D;&#x0A; return err;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (data.length &gt; 1) {&#x0D;&#x0A; return { type: packetslist[type], data: data.substring(1) };&#x0D;&#x0A; } else {&#x0D;&#x0A; return { type: packetslist[type] };&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var asArray = new Uint8Array(data);&#x0D;&#x0A; var type = asArray[0];&#x0D;&#x0A; var rest = sliceBuffer(data, 1);&#x0D;&#x0A; if (Blob &amp;&amp; binaryType === &apos;blob&apos;) {&#x0D;&#x0A; rest = new Blob([rest]);&#x0D;&#x0A; }&#x0D;&#x0A; return { type: packetslist[type], data: rest };&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Decodes a packet encoded in a base64 string&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} base64 encoded message&#x0D;&#x0A; * @return {Object} with `type` and `data` (if any)&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.decodeBase64Packet = function(msg, binaryType) {&#x0D;&#x0A; var type = packetslist[msg.charAt(0)];&#x0D;&#x0A; if (!global.ArrayBuffer) {&#x0D;&#x0A; return { type: type, data: { base64: true, data: msg.substr(1) } };&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var data = base64encoder.decode(msg.substr(1));&#x0D;&#x0A;&#x0D;&#x0A; if (binaryType === &apos;blob&apos; &amp;&amp; Blob) {&#x0D;&#x0A; data = new Blob([data]);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return { type: type, data: data };&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encodes multiple messages (payload).&#x0D;&#x0A; *&#x0D;&#x0A; * &lt;length&gt;:data&#x0D;&#x0A; *&#x0D;&#x0A; * Example:&#x0D;&#x0A; *&#x0D;&#x0A; * 11:hello world2:hi&#x0D;&#x0A; *&#x0D;&#x0A; * If any contents are binary, they will be encoded as base64 strings. Base64&#x0D;&#x0A; * encoded strings are marked with a b before the length specifier&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Array} packets&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.encodePayload = function (packets, supportsBinary, callback) {&#x0D;&#x0A; if (typeof supportsBinary == &apos;function&apos;) {&#x0D;&#x0A; callback = supportsBinary;&#x0D;&#x0A; supportsBinary = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var isBinary = hasBinary(packets);&#x0D;&#x0A;&#x0D;&#x0A; if (supportsBinary &amp;&amp; isBinary) {&#x0D;&#x0A; if (Blob &amp;&amp; !dontSendBlobs) {&#x0D;&#x0A; return exports.encodePayloadAsBlob(packets, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return exports.encodePayloadAsArrayBuffer(packets, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (!packets.length) {&#x0D;&#x0A; return callback(&apos;0:&apos;);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function setLengthHeader(message) {&#x0D;&#x0A; return message.length + &apos;:&apos; + message;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function encodeOne(packet, doneCallback) {&#x0D;&#x0A; exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {&#x0D;&#x0A; doneCallback(null, setLengthHeader(message));&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; map(packets, encodeOne, function(err, results) {&#x0D;&#x0A; return callback(results.join(&apos;&apos;));&#x0D;&#x0A; });&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Async array map using after&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function map(ary, each, done) {&#x0D;&#x0A; var result = new Array(ary.length);&#x0D;&#x0A; var next = after(ary.length, done);&#x0D;&#x0A;&#x0D;&#x0A; var eachWithIndex = function(i, el, cb) {&#x0D;&#x0A; each(el, function(error, msg) {&#x0D;&#x0A; result[i] = msg;&#x0D;&#x0A; cb(error, result);&#x0D;&#x0A; });&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; for (var i = 0; i &lt; ary.length; i++) {&#x0D;&#x0A; eachWithIndex(i, ary[i], next);&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/*&#x0D;&#x0A; * Decodes data when a payload is maybe expected. Possible binary contents are&#x0D;&#x0A; * decoded from their base64 representation&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} data, callback method&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.decodePayload = function (data, binaryType, callback) {&#x0D;&#x0A; if (typeof data != &apos;string&apos;) {&#x0D;&#x0A; return exports.decodePayloadAsBinary(data, binaryType, callback);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (typeof binaryType === &apos;function&apos;) {&#x0D;&#x0A; callback = binaryType;&#x0D;&#x0A; binaryType = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var packet;&#x0D;&#x0A; if (data == &apos;&apos;) {&#x0D;&#x0A; // parser error - ignoring payload&#x0D;&#x0A; return callback(err, 0, 1);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var length = &apos;&apos;&#x0D;&#x0A; , n, msg;&#x0D;&#x0A;&#x0D;&#x0A; for (var i = 0, l = data.length; i &lt; l; i++) {&#x0D;&#x0A; var chr = data.charAt(i);&#x0D;&#x0A;&#x0D;&#x0A; if (&apos;:&apos; != chr) {&#x0D;&#x0A; length += chr;&#x0D;&#x0A; } else {&#x0D;&#x0A; if (&apos;&apos; == length || (length != (n = Number(length)))) {&#x0D;&#x0A; // parser error - ignoring payload&#x0D;&#x0A; return callback(err, 0, 1);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; msg = data.substr(i + 1, n);&#x0D;&#x0A;&#x0D;&#x0A; if (length != msg.length) {&#x0D;&#x0A; // parser error - ignoring payload&#x0D;&#x0A; return callback(err, 0, 1);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (msg.length) {&#x0D;&#x0A; packet = exports.decodePacket(msg, binaryType, true);&#x0D;&#x0A;&#x0D;&#x0A; if (err.type == packet.type &amp;&amp; err.data == packet.data) {&#x0D;&#x0A; // parser error in individual packet - ignoring payload&#x0D;&#x0A; return callback(err, 0, 1);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var ret = callback(packet, i + n, l);&#x0D;&#x0A; if (false === ret) return;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // advance cursor&#x0D;&#x0A; i += n;&#x0D;&#x0A; length = &apos;&apos;;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (length != &apos;&apos;) {&#x0D;&#x0A; // parser error - ignoring payload&#x0D;&#x0A; return callback(err, 0, 1);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encodes multiple messages (payload) as binary.&#x0D;&#x0A; *&#x0D;&#x0A; * &lt;1 = binary, 0 = string&gt;&lt;number from 0-9&gt;&lt;number from 0-9&gt;[...]&lt;number&#x0D;&#x0A; * 255&gt;&lt;data&gt;&#x0D;&#x0A; *&#x0D;&#x0A; * Example:&#x0D;&#x0A; * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Array} packets&#x0D;&#x0A; * @return {ArrayBuffer} encoded payload&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.encodePayloadAsArrayBuffer = function(packets, callback) {&#x0D;&#x0A; if (!packets.length) {&#x0D;&#x0A; return callback(new ArrayBuffer(0));&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; function encodeOne(packet, doneCallback) {&#x0D;&#x0A; exports.encodePacket(packet, true, true, function(data) {&#x0D;&#x0A; return doneCallback(null, data);&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; map(packets, encodeOne, function(err, encodedPackets) {&#x0D;&#x0A; var totalLength = encodedPackets.reduce(function(acc, p) {&#x0D;&#x0A; var len;&#x0D;&#x0A; if (typeof p === &apos;string&apos;){&#x0D;&#x0A; len = p.length;&#x0D;&#x0A; } else {&#x0D;&#x0A; len = p.byteLength;&#x0D;&#x0A; }&#x0D;&#x0A; return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2&#x0D;&#x0A; }, 0);&#x0D;&#x0A;&#x0D;&#x0A; var resultArray = new Uint8Array(totalLength);&#x0D;&#x0A;&#x0D;&#x0A; var bufferIndex = 0;&#x0D;&#x0A; encodedPackets.forEach(function(p) {&#x0D;&#x0A; var isString = typeof p === &apos;string&apos;;&#x0D;&#x0A; var ab = p;&#x0D;&#x0A; if (isString) {&#x0D;&#x0A; var view = new Uint8Array(p.length);&#x0D;&#x0A; for (var i = 0; i &lt; p.length; i++) {&#x0D;&#x0A; view[i] = p.charCodeAt(i);&#x0D;&#x0A; }&#x0D;&#x0A; ab = view.buffer;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (isString) { // not true binary&#x0D;&#x0A; resultArray[bufferIndex++] = 0;&#x0D;&#x0A; } else { // true binary&#x0D;&#x0A; resultArray[bufferIndex++] = 1;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var lenStr = ab.byteLength.toString();&#x0D;&#x0A; for (var i = 0; i &lt; lenStr.length; i++) {&#x0D;&#x0A; resultArray[bufferIndex++] = parseInt(lenStr[i]);&#x0D;&#x0A; }&#x0D;&#x0A; resultArray[bufferIndex++] = 255;&#x0D;&#x0A;&#x0D;&#x0A; var view = new Uint8Array(ab);&#x0D;&#x0A; for (var i = 0; i &lt; view.length; i++) {&#x0D;&#x0A; resultArray[bufferIndex++] = view[i];&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A;&#x0D;&#x0A; return callback(resultArray.buffer);&#x0D;&#x0A; });&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encode as Blob&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.encodePayloadAsBlob = function(packets, callback) {&#x0D;&#x0A; function encodeOne(packet, doneCallback) {&#x0D;&#x0A; exports.encodePacket(packet, true, true, function(encoded) {&#x0D;&#x0A; var binaryIdentifier = new Uint8Array(1);&#x0D;&#x0A; binaryIdentifier[0] = 1;&#x0D;&#x0A; if (typeof encoded === &apos;string&apos;) {&#x0D;&#x0A; var view = new Uint8Array(encoded.length);&#x0D;&#x0A; for (var i = 0; i &lt; encoded.length; i++) {&#x0D;&#x0A; view[i] = encoded.charCodeAt(i);&#x0D;&#x0A; }&#x0D;&#x0A; encoded = view.buffer;&#x0D;&#x0A; binaryIdentifier[0] = 0;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var len = (encoded instanceof ArrayBuffer)&#x0D;&#x0A; ? encoded.byteLength&#x0D;&#x0A; : encoded.size;&#x0D;&#x0A;&#x0D;&#x0A; var lenStr = len.toString();&#x0D;&#x0A; var lengthAry = new Uint8Array(lenStr.length + 1);&#x0D;&#x0A; for (var i = 0; i &lt; lenStr.length; i++) {&#x0D;&#x0A; lengthAry[i] = parseInt(lenStr[i]);&#x0D;&#x0A; }&#x0D;&#x0A; lengthAry[lenStr.length] = 255;&#x0D;&#x0A;&#x0D;&#x0A; if (Blob) {&#x0D;&#x0A; var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);&#x0D;&#x0A; doneCallback(null, blob);&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; map(packets, encodeOne, function(err, results) {&#x0D;&#x0A; return callback(new Blob(results));&#x0D;&#x0A; });&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/*&#x0D;&#x0A; * Decodes data when a payload is maybe expected. Strings are decoded by&#x0D;&#x0A; * interpreting each byte as a key code for entries marked to start with 0. See&#x0D;&#x0A; * description of encodePayloadAsBinary&#x0D;&#x0A; *&#x0D;&#x0A; * @param {ArrayBuffer} data, callback method&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.decodePayloadAsBinary = function (data, binaryType, callback) {&#x0D;&#x0A; if (typeof binaryType === &apos;function&apos;) {&#x0D;&#x0A; callback = binaryType;&#x0D;&#x0A; binaryType = null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var bufferTail = data;&#x0D;&#x0A; var buffers = [];&#x0D;&#x0A;&#x0D;&#x0A; var numberTooLong = false;&#x0D;&#x0A; while (bufferTail.byteLength &gt; 0) {&#x0D;&#x0A; var tailArray = new Uint8Array(bufferTail);&#x0D;&#x0A; var isString = tailArray[0] === 0;&#x0D;&#x0A; var msgLength = &apos;&apos;;&#x0D;&#x0A;&#x0D;&#x0A; for (var i = 1; ; i++) {&#x0D;&#x0A; if (tailArray[i] == 255) break;&#x0D;&#x0A;&#x0D;&#x0A; if (msgLength.length &gt; 310) {&#x0D;&#x0A; numberTooLong = true;&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; msgLength += tailArray[i];&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if(numberTooLong) return callback(err, 0, 1);&#x0D;&#x0A;&#x0D;&#x0A; bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);&#x0D;&#x0A; msgLength = parseInt(msgLength);&#x0D;&#x0A;&#x0D;&#x0A; var msg = sliceBuffer(bufferTail, 0, msgLength);&#x0D;&#x0A; if (isString) {&#x0D;&#x0A; try {&#x0D;&#x0A; msg = String.fromCharCode.apply(null, new Uint8Array(msg));&#x0D;&#x0A; } catch (e) {&#x0D;&#x0A; // iPhone Safari doesn&apos;t let you apply to typed arrays&#x0D;&#x0A; var typed = new Uint8Array(msg);&#x0D;&#x0A; msg = &apos;&apos;;&#x0D;&#x0A; for (var i = 0; i &lt; typed.length; i++) {&#x0D;&#x0A; msg += String.fromCharCode(typed[i]);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; buffers.push(msg);&#x0D;&#x0A; bufferTail = sliceBuffer(bufferTail, msgLength);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var total = buffers.length;&#x0D;&#x0A; buffers.forEach(function(buffer, i) {&#x0D;&#x0A; callback(exports.decodePacket(buffer, binaryType, true), i, total);&#x0D;&#x0A; });&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;./keys&quot;:28,&quot;after&quot;:6,&quot;arraybuffer.slice&quot;:7,&quot;base64-arraybuffer&quot;:9,&quot;blob&quot;:10,&quot;has-binary&quot;:29,&quot;utf8&quot;:44}],28:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Gets the keys for an object.&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Array} keys&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = Object.keys || function keys (obj){&#x0D;&#x0A; var arr = [];&#x0D;&#x0A; var has = Object.prototype.hasOwnProperty;&#x0D;&#x0A;&#x0D;&#x0A; for (var i in obj) {&#x0D;&#x0A; if (has.call(obj, i)) {&#x0D;&#x0A; arr.push(i);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return arr;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],29:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;&#x0D;&#x0A;/*&#x0D;&#x0A; * Module requirements.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var isArray = _dereq_(&apos;isarray&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = hasBinary;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Checks for binary data.&#x0D;&#x0A; *&#x0D;&#x0A; * Right now only Buffer and ArrayBuffer are supported..&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} anything&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function hasBinary(data) {&#x0D;&#x0A;&#x0D;&#x0A; function _hasBinary(obj) {&#x0D;&#x0A; if (!obj) return false;&#x0D;&#x0A;&#x0D;&#x0A; if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||&#x0D;&#x0A; (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||&#x0D;&#x0A; (global.Blob &amp;&amp; obj instanceof Blob) ||&#x0D;&#x0A; (global.File &amp;&amp; obj instanceof File)&#x0D;&#x0A; ) {&#x0D;&#x0A; return true;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (isArray(obj)) {&#x0D;&#x0A; for (var i = 0; i &lt; obj.length; i++) {&#x0D;&#x0A; if (_hasBinary(obj[i])) {&#x0D;&#x0A; return true;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {&#x0D;&#x0A; if (obj.toJSON) {&#x0D;&#x0A; obj = obj.toJSON();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; for (var key in obj) {&#x0D;&#x0A; if (Object.prototype.hasOwnProperty.call(obj, key) &amp;&amp; _hasBinary(obj[key])) {&#x0D;&#x0A; return true;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return false;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return _hasBinary(data);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;isarray&quot;:33}],30:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;&#x0D;&#x0A;/*&#x0D;&#x0A; * Module requirements.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var isArray = _dereq_(&apos;isarray&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = hasBinary;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Checks for binary data.&#x0D;&#x0A; *&#x0D;&#x0A; * Right now only Buffer and ArrayBuffer are supported..&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} anything&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function hasBinary(data) {&#x0D;&#x0A;&#x0D;&#x0A; function _hasBinary(obj) {&#x0D;&#x0A; if (!obj) return false;&#x0D;&#x0A;&#x0D;&#x0A; if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer &amp;&amp; global.Buffer.isBuffer(obj)) ||&#x0D;&#x0A; (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||&#x0D;&#x0A; (global.Blob &amp;&amp; obj instanceof Blob) ||&#x0D;&#x0A; (global.File &amp;&amp; obj instanceof File)&#x0D;&#x0A; ) {&#x0D;&#x0A; return true;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (isArray(obj)) {&#x0D;&#x0A; for (var i = 0; i &lt; obj.length; i++) {&#x0D;&#x0A; if (_hasBinary(obj[i])) {&#x0D;&#x0A; return true;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; } else if (obj &amp;&amp; &apos;object&apos; == typeof obj) {&#x0D;&#x0A; // see: https://github.com/Automattic/has-binary/pull/4&#x0D;&#x0A; if (obj.toJSON &amp;&amp; &apos;function&apos; == typeof obj.toJSON) {&#x0D;&#x0A; obj = obj.toJSON();&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; for (var key in obj) {&#x0D;&#x0A; if (Object.prototype.hasOwnProperty.call(obj, key) &amp;&amp; _hasBinary(obj[key])) {&#x0D;&#x0A; return true;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return false;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return _hasBinary(data);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;isarray&quot;:33}],31:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module exports.&#x0D;&#x0A; *&#x0D;&#x0A; * Logic borrowed from Modernizr:&#x0D;&#x0A; *&#x0D;&#x0A; * - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;try {&#x0D;&#x0A; module.exports = typeof XMLHttpRequest !== &apos;undefined&apos; &amp;&amp;&#x0D;&#x0A; &apos;withCredentials&apos; in new XMLHttpRequest();&#x0D;&#x0A;} catch (err) {&#x0D;&#x0A; // if XMLHttp support is disabled in IE then it will throw&#x0D;&#x0A; // when trying to create&#x0D;&#x0A; module.exports = false;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{}],32:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;var indexOf = [].indexOf;&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function(arr, obj){&#x0D;&#x0A; if (indexOf) return arr.indexOf(obj);&#x0D;&#x0A; for (var i = 0; i &lt; arr.length; ++i) {&#x0D;&#x0A; if (arr[i] === obj) return i;&#x0D;&#x0A; }&#x0D;&#x0A; return -1;&#x0D;&#x0A;};&#x0D;&#x0A;},{}],33:[function(_dereq_,module,exports){&#x0D;&#x0A;module.exports = Array.isArray || function (arr) {&#x0D;&#x0A; return Object.prototype.toString.call(arr) == &apos;[object Array]&apos;;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],34:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */&#x0D;&#x0A;;(function () {&#x0D;&#x0A; // Detect the `define` function exposed by asynchronous module loaders. The&#x0D;&#x0A; // strict `define` check is necessary for compatibility with `r.js`.&#x0D;&#x0A; var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;&#x0D;&#x0A;&#x0D;&#x0A; // A set of types used to distinguish objects from primitives.&#x0D;&#x0A; var objectTypes = {&#x0D;&#x0A; &quot;function&quot;: true,&#x0D;&#x0A; &quot;object&quot;: true&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Detect the `exports` object exposed by CommonJS implementations.&#x0D;&#x0A; var freeExports = objectTypes[typeof exports] &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;&#x0D;&#x0A;&#x0D;&#x0A; // Use the `global` object exposed by Node (including Browserify via&#x0D;&#x0A; // `insert-module-globals`), Narwhal, and Ringo as the default context,&#x0D;&#x0A; // and the `window` object in browsers. Rhino exports a `global` function&#x0D;&#x0A; // instead.&#x0D;&#x0A; var root = objectTypes[typeof window] &amp;&amp; window || this,&#x0D;&#x0A; freeGlobal = freeExports &amp;&amp; objectTypes[typeof module] &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; typeof global == &quot;object&quot; &amp;&amp; global;&#x0D;&#x0A;&#x0D;&#x0A; if (freeGlobal &amp;&amp; (freeGlobal[&quot;global&quot;] === freeGlobal || freeGlobal[&quot;window&quot;] === freeGlobal || freeGlobal[&quot;self&quot;] === freeGlobal)) {&#x0D;&#x0A; root = freeGlobal;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // Public: Initializes JSON 3 using the given `context` object, attaching the&#x0D;&#x0A; // `stringify` and `parse` functions to the specified `exports` object.&#x0D;&#x0A; function runInContext(context, exports) {&#x0D;&#x0A; context || (context = root[&quot;Object&quot;]());&#x0D;&#x0A; exports || (exports = root[&quot;Object&quot;]());&#x0D;&#x0A;&#x0D;&#x0A; // Native constructor aliases.&#x0D;&#x0A; var Number = context[&quot;Number&quot;] || root[&quot;Number&quot;],&#x0D;&#x0A; String = context[&quot;String&quot;] || root[&quot;String&quot;],&#x0D;&#x0A; Object = context[&quot;Object&quot;] || root[&quot;Object&quot;],&#x0D;&#x0A; Date = context[&quot;Date&quot;] || root[&quot;Date&quot;],&#x0D;&#x0A; SyntaxError = context[&quot;SyntaxError&quot;] || root[&quot;SyntaxError&quot;],&#x0D;&#x0A; TypeError = context[&quot;TypeError&quot;] || root[&quot;TypeError&quot;],&#x0D;&#x0A; Math = context[&quot;Math&quot;] || root[&quot;Math&quot;],&#x0D;&#x0A; nativeJSON = context[&quot;JSON&quot;] || root[&quot;JSON&quot;];&#x0D;&#x0A;&#x0D;&#x0A; // Delegate to the native `stringify` and `parse` implementations.&#x0D;&#x0A; if (typeof nativeJSON == &quot;object&quot; &amp;&amp; nativeJSON) {&#x0D;&#x0A; exports.stringify = nativeJSON.stringify;&#x0D;&#x0A; exports.parse = nativeJSON.parse;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // Convenience aliases.&#x0D;&#x0A; var objectProto = Object.prototype,&#x0D;&#x0A; getClass = objectProto.toString,&#x0D;&#x0A; isProperty, forEach, undef;&#x0D;&#x0A;&#x0D;&#x0A; // Test the `Date#getUTC*` methods. Based on work by @Yaffle.&#x0D;&#x0A; var isExtended = new Date(-3509827334573292);&#x0D;&#x0A; try {&#x0D;&#x0A; // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical&#x0D;&#x0A; // results for certain dates in Opera &gt;= 10.53.&#x0D;&#x0A; isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;&#x0D;&#x0A; // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,&#x0D;&#x0A; // but clips the values returned by the date methods to the range of&#x0D;&#x0A; // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).&#x0D;&#x0A; isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;&#x0D;&#x0A; } catch (exception) {}&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Determines whether the native `JSON.stringify` and `parse`&#x0D;&#x0A; // implementations are spec-compliant. Based on work by Ken Snyder.&#x0D;&#x0A; function has(name) {&#x0D;&#x0A; if (has[name] !== undef) {&#x0D;&#x0A; // Return cached feature test result.&#x0D;&#x0A; return has[name];&#x0D;&#x0A; }&#x0D;&#x0A; var isSupported;&#x0D;&#x0A; if (name == &quot;bug-string-char-index&quot;) {&#x0D;&#x0A; // IE &lt;= 7 doesn&apos;t support accessing string characters using square&#x0D;&#x0A; // bracket notation. IE 8 only supports this for primitives.&#x0D;&#x0A; isSupported = &quot;a&quot;[0] != &quot;a&quot;;&#x0D;&#x0A; } else if (name == &quot;json&quot;) {&#x0D;&#x0A; // Indicates whether both `JSON.stringify` and `JSON.parse` are&#x0D;&#x0A; // supported.&#x0D;&#x0A; isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);&#x0D;&#x0A; } else {&#x0D;&#x0A; var value, serialized = &apos;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&apos;;&#x0D;&#x0A; // Test `JSON.stringify`.&#x0D;&#x0A; if (name == &quot;json-stringify&quot;) {&#x0D;&#x0A; var stringify = exports.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;&#x0D;&#x0A; if (stringifySupported) {&#x0D;&#x0A; // A test function object with a custom `toJSON` method.&#x0D;&#x0A; (value = function () {&#x0D;&#x0A; return 1;&#x0D;&#x0A; }).toJSON = value;&#x0D;&#x0A; try {&#x0D;&#x0A; stringifySupported =&#x0D;&#x0A; // Firefox 3.1b1 and b2 serialize string, number, and boolean&#x0D;&#x0A; // primitives as object literals.&#x0D;&#x0A; stringify(0) === &quot;0&quot; &amp;&amp;&#x0D;&#x0A; // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object&#x0D;&#x0A; // literals.&#x0D;&#x0A; stringify(new Number()) === &quot;0&quot; &amp;&amp;&#x0D;&#x0A; stringify(new String()) == &apos;&quot;&quot;&apos; &amp;&amp;&#x0D;&#x0A; // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or&#x0D;&#x0A; // does not define a canonical JSON representation (this applies to&#x0D;&#x0A; // objects with `toJSON` properties as well, *unless* they are nested&#x0D;&#x0A; // within an object or array).&#x0D;&#x0A; stringify(getClass) === undef &amp;&amp;&#x0D;&#x0A; // IE 8 serializes `undefined` as `&quot;undefined&quot;`. Safari &lt;= 5.1.7 and&#x0D;&#x0A; // FF 3.1b3 pass this test.&#x0D;&#x0A; stringify(undef) === undef &amp;&amp;&#x0D;&#x0A; // Safari &lt;= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,&#x0D;&#x0A; // respectively, if the value is omitted entirely.&#x0D;&#x0A; stringify() === undef &amp;&amp;&#x0D;&#x0A; // FF 3.1b1, 2 throw an error if the given value is not a number,&#x0D;&#x0A; // string, array, object, Boolean, or `null` literal. This applies to&#x0D;&#x0A; // objects with custom `toJSON` methods as well, unless they are nested&#x0D;&#x0A; // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`&#x0D;&#x0A; // methods entirely.&#x0D;&#x0A; stringify(value) === &quot;1&quot; &amp;&amp;&#x0D;&#x0A; stringify([value]) == &quot;[1]&quot; &amp;&amp;&#x0D;&#x0A; // Prototype &lt;= 1.6.1 serializes `[undefined]` as `&quot;[]&quot;` instead of&#x0D;&#x0A; // `&quot;[null]&quot;`.&#x0D;&#x0A; stringify([undef]) == &quot;[null]&quot; &amp;&amp;&#x0D;&#x0A; // YUI 3.0.0b1 fails to serialize `null` literals.&#x0D;&#x0A; stringify(null) == &quot;null&quot; &amp;&amp;&#x0D;&#x0A; // FF 3.1b1, 2 halts serialization if an array contains a function:&#x0D;&#x0A; // `[1, true, getClass, 1]` serializes as &quot;[1,true,],&quot;. FF 3.1b3&#x0D;&#x0A; // elides non-JSON values from objects and arrays, unless they&#x0D;&#x0A; // define custom `toJSON` methods.&#x0D;&#x0A; stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;&#x0D;&#x0A; // Simple serialization test. FF 3.1b1 uses Unicode escape sequences&#x0D;&#x0A; // where character escape codes are expected (e.g., `\b` =&gt; `\u0008`).&#x0D;&#x0A; stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;&#x0D;&#x0A; // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.&#x0D;&#x0A; stringify(null, value) === &quot;1&quot; &amp;&amp;&#x0D;&#x0A; stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;&#x0D;&#x0A; // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly&#x0D;&#x0A; // serialize extended years.&#x0D;&#x0A; stringify(new Date(-8.64e15)) == &apos;&quot;-271821-04-20T00:00:00.000Z&quot;&apos; &amp;&amp;&#x0D;&#x0A; // The milliseconds are optional in ES 5, but required in 5.1.&#x0D;&#x0A; stringify(new Date(8.64e15)) == &apos;&quot;+275760-09-13T00:00:00.000Z&quot;&apos; &amp;&amp;&#x0D;&#x0A; // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative&#x0D;&#x0A; // four-digit years instead of six-digit years. Credits: @Yaffle.&#x0D;&#x0A; stringify(new Date(-621987552e5)) == &apos;&quot;-000001-01-01T00:00:00.000Z&quot;&apos; &amp;&amp;&#x0D;&#x0A; // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond&#x0D;&#x0A; // values less than 1000. Credits: @Yaffle.&#x0D;&#x0A; stringify(new Date(-1)) == &apos;&quot;1969-12-31T23:59:59.999Z&quot;&apos;;&#x0D;&#x0A; } catch (exception) {&#x0D;&#x0A; stringifySupported = false;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; isSupported = stringifySupported;&#x0D;&#x0A; }&#x0D;&#x0A; // Test `JSON.parse`.&#x0D;&#x0A; if (name == &quot;json-parse&quot;) {&#x0D;&#x0A; var parse = exports.parse;&#x0D;&#x0A; if (typeof parse == &quot;function&quot;) {&#x0D;&#x0A; try {&#x0D;&#x0A; // FF 3.1b1, b2 will throw an exception if a bare literal is provided.&#x0D;&#x0A; // Conforming implementations should also coerce the initial argument to&#x0D;&#x0A; // a string prior to parsing.&#x0D;&#x0A; if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {&#x0D;&#x0A; // Simple parsing test.&#x0D;&#x0A; value = parse(serialized);&#x0D;&#x0A; var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;&#x0D;&#x0A; if (parseSupported) {&#x0D;&#x0A; try {&#x0D;&#x0A; // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.&#x0D;&#x0A; parseSupported = !parse(&apos;&quot;\t&quot;&apos;);&#x0D;&#x0A; } catch (exception) {}&#x0D;&#x0A; if (parseSupported) {&#x0D;&#x0A; try {&#x0D;&#x0A; // FF 4.0 and 4.0.1 allow leading `+` signs and leading&#x0D;&#x0A; // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow&#x0D;&#x0A; // certain octal literals.&#x0D;&#x0A; parseSupported = parse(&quot;01&quot;) !== 1;&#x0D;&#x0A; } catch (exception) {}&#x0D;&#x0A; }&#x0D;&#x0A; if (parseSupported) {&#x0D;&#x0A; try {&#x0D;&#x0A; // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal&#x0D;&#x0A; // points. These environments, along with FF 3.1b1 and 2,&#x0D;&#x0A; // also allow trailing commas in JSON objects and arrays.&#x0D;&#x0A; parseSupported = parse(&quot;1.&quot;) !== 1;&#x0D;&#x0A; } catch (exception) {}&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; } catch (exception) {&#x0D;&#x0A; parseSupported = false;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; isSupported = parseSupported;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return has[name] = !!isSupported;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (!has(&quot;json&quot;)) {&#x0D;&#x0A; // Common `[[Class]]` name aliases.&#x0D;&#x0A; var functionClass = &quot;[object Function]&quot;,&#x0D;&#x0A; dateClass = &quot;[object Date]&quot;,&#x0D;&#x0A; numberClass = &quot;[object Number]&quot;,&#x0D;&#x0A; stringClass = &quot;[object String]&quot;,&#x0D;&#x0A; arrayClass = &quot;[object Array]&quot;,&#x0D;&#x0A; booleanClass = &quot;[object Boolean]&quot;;&#x0D;&#x0A;&#x0D;&#x0A; // Detect incomplete support for accessing string characters by index.&#x0D;&#x0A; var charIndexBuggy = has(&quot;bug-string-char-index&quot;);&#x0D;&#x0A;&#x0D;&#x0A; // Define additional utility methods if the `Date` methods are buggy.&#x0D;&#x0A; if (!isExtended) {&#x0D;&#x0A; var floor = Math.floor;&#x0D;&#x0A; // A mapping between the months of the year and the number of days between&#x0D;&#x0A; // January 1st and the first of the respective month.&#x0D;&#x0A; var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];&#x0D;&#x0A; // Internal: Calculates the number of days between the Unix epoch and the&#x0D;&#x0A; // first day of the given month.&#x0D;&#x0A; var getDay = function (year, month) {&#x0D;&#x0A; return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Determines if a property is a direct property of the given&#x0D;&#x0A; // object. Delegates to the native `Object#hasOwnProperty` method.&#x0D;&#x0A; if (!(isProperty = objectProto.hasOwnProperty)) {&#x0D;&#x0A; isProperty = function (property) {&#x0D;&#x0A; var members = {}, constructor;&#x0D;&#x0A; if ((members.__proto__ = null, members.__proto__ = {&#x0D;&#x0A; // The *proto* property cannot be set multiple times in recent&#x0D;&#x0A; // versions of Firefox and SeaMonkey.&#x0D;&#x0A; &quot;toString&quot;: 1&#x0D;&#x0A; }, members).toString != getClass) {&#x0D;&#x0A; // Safari &lt;= 2.0.3 doesn&apos;t implement `Object#hasOwnProperty`, but&#x0D;&#x0A; // supports the mutable *proto* property.&#x0D;&#x0A; isProperty = function (property) {&#x0D;&#x0A; // Capture and break the object&apos;s prototype chain (see section 8.6.2&#x0D;&#x0A; // of the ES 5.1 spec). The parenthesized expression prevents an&#x0D;&#x0A; // unsafe transformation by the Closure Compiler.&#x0D;&#x0A; var original = this.__proto__, result = property in (this.__proto__ = null, this);&#x0D;&#x0A; // Restore the original prototype chain.&#x0D;&#x0A; this.__proto__ = original;&#x0D;&#x0A; return result;&#x0D;&#x0A; };&#x0D;&#x0A; } else {&#x0D;&#x0A; // Capture a reference to the top-level `Object` constructor.&#x0D;&#x0A; constructor = members.constructor;&#x0D;&#x0A; // Use the `constructor` property to simulate `Object#hasOwnProperty` in&#x0D;&#x0A; // other environments.&#x0D;&#x0A; isProperty = function (property) {&#x0D;&#x0A; var parent = (this.constructor || constructor).prototype;&#x0D;&#x0A; return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A; members = null;&#x0D;&#x0A; return isProperty.call(this, property);&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Normalizes the `for...in` iteration algorithm across&#x0D;&#x0A; // environments. Each enumerated key is yielded to a `callback` function.&#x0D;&#x0A; forEach = function (object, callback) {&#x0D;&#x0A; var size = 0, Properties, members, property;&#x0D;&#x0A;&#x0D;&#x0A; // Tests for bugs in the current environment&apos;s `for...in` algorithm. The&#x0D;&#x0A; // `valueOf` property inherits the non-enumerable flag from&#x0D;&#x0A; // `Object.prototype` in older versions of IE, Netscape, and Mozilla.&#x0D;&#x0A; (Properties = function () {&#x0D;&#x0A; this.valueOf = 0;&#x0D;&#x0A; }).prototype.valueOf = 0;&#x0D;&#x0A;&#x0D;&#x0A; // Iterate over a new instance of the `Properties` class.&#x0D;&#x0A; members = new Properties();&#x0D;&#x0A; for (property in members) {&#x0D;&#x0A; // Ignore all properties inherited from `Object.prototype`.&#x0D;&#x0A; if (isProperty.call(members, property)) {&#x0D;&#x0A; size++;&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; Properties = members = null;&#x0D;&#x0A;&#x0D;&#x0A; // Normalize the iteration algorithm.&#x0D;&#x0A; if (!size) {&#x0D;&#x0A; // A list of non-enumerable properties inherited from `Object.prototype`.&#x0D;&#x0A; members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];&#x0D;&#x0A; // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable&#x0D;&#x0A; // properties.&#x0D;&#x0A; forEach = function (object, callback) {&#x0D;&#x0A; var isFunction = getClass.call(object) == functionClass, property, length;&#x0D;&#x0A; var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &quot;function&quot; &amp;&amp; objectTypes[typeof object.hasOwnProperty] &amp;&amp; object.hasOwnProperty || isProperty;&#x0D;&#x0A; for (property in object) {&#x0D;&#x0A; // Gecko &lt;= 1.0 enumerates the `prototype` property of functions under&#x0D;&#x0A; // certain conditions; IE does not.&#x0D;&#x0A; if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {&#x0D;&#x0A; callback(property);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Manually invoke the callback for each non-enumerable property.&#x0D;&#x0A; for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));&#x0D;&#x0A; };&#x0D;&#x0A; } else if (size == 2) {&#x0D;&#x0A; // Safari &lt;= 2.0.4 enumerates shadowed properties twice.&#x0D;&#x0A; forEach = function (object, callback) {&#x0D;&#x0A; // Create a set of iterated properties.&#x0D;&#x0A; var members = {}, isFunction = getClass.call(object) == functionClass, property;&#x0D;&#x0A; for (property in object) {&#x0D;&#x0A; // Store each property name to prevent double enumeration. The&#x0D;&#x0A; // `prototype` property of functions is not enumerated due to cross-&#x0D;&#x0A; // environment inconsistencies.&#x0D;&#x0A; if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {&#x0D;&#x0A; callback(property);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A; } else {&#x0D;&#x0A; // No bugs detected; use the standard `for...in` algorithm.&#x0D;&#x0A; forEach = function (object, callback) {&#x0D;&#x0A; var isFunction = getClass.call(object) == functionClass, property, isConstructor;&#x0D;&#x0A; for (property in object) {&#x0D;&#x0A; if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {&#x0D;&#x0A; callback(property);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Manually invoke the callback for the `constructor` property due to&#x0D;&#x0A; // cross-environment inconsistencies.&#x0D;&#x0A; if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {&#x0D;&#x0A; callback(property);&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A; return forEach(object, callback);&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Public: Serializes a JavaScript `value` as a JSON string. The optional&#x0D;&#x0A; // `filter` argument may specify either a function that alters how object and&#x0D;&#x0A; // array members are serialized, or an array of strings and numbers that&#x0D;&#x0A; // indicates which properties should be serialized. The optional `width`&#x0D;&#x0A; // argument may be either a string or number that specifies the indentation&#x0D;&#x0A; // level of the output.&#x0D;&#x0A; if (!has(&quot;json-stringify&quot;)) {&#x0D;&#x0A; // Internal: A map of control characters and their escaped equivalents.&#x0D;&#x0A; var Escapes = {&#x0D;&#x0A; 92: &quot;\\\\&quot;,&#x0D;&#x0A; 34: &apos;\\&quot;&apos;,&#x0D;&#x0A; 8: &quot;\\b&quot;,&#x0D;&#x0A; 12: &quot;\\f&quot;,&#x0D;&#x0A; 10: &quot;\\n&quot;,&#x0D;&#x0A; 13: &quot;\\r&quot;,&#x0D;&#x0A; 9: &quot;\\t&quot;&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Converts `value` into a zero-padded string such that its&#x0D;&#x0A; // length is at least equal to `width`. The `width` must be &lt;= 6.&#x0D;&#x0A; var leadingZeroes = &quot;000000&quot;;&#x0D;&#x0A; var toPaddedString = function (width, value) {&#x0D;&#x0A; // The `|| 0` expression is necessary to work around a bug in&#x0D;&#x0A; // Opera &lt;= 7.54u2 where `0 == -0`, but `String(-0) !== &quot;0&quot;`.&#x0D;&#x0A; return (leadingZeroes + (value || 0)).slice(-width);&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Double-quotes a string `value`, replacing all ASCII control&#x0D;&#x0A; // characters (characters with code unit values between 0 and 31) with&#x0D;&#x0A; // their escaped equivalents. This is an implementation of the&#x0D;&#x0A; // `Quote(value)` operation defined in ES 5.1 section 15.12.3.&#x0D;&#x0A; var unicodePrefix = &quot;\\u00&quot;;&#x0D;&#x0A; var quote = function (value) {&#x0D;&#x0A; var result = &apos;&quot;&apos;, index = 0, length = value.length, useCharIndex = !charIndexBuggy || length &gt; 10;&#x0D;&#x0A; var symbols = useCharIndex &amp;&amp; (charIndexBuggy ? value.split(&quot;&quot;) : value);&#x0D;&#x0A; for (; index &lt; length; index++) {&#x0D;&#x0A; var charCode = value.charCodeAt(index);&#x0D;&#x0A; // If the character is a control character, append its Unicode or&#x0D;&#x0A; // shorthand escape sequence; otherwise, append the character as-is.&#x0D;&#x0A; switch (charCode) {&#x0D;&#x0A; case 8: case 9: case 10: case 12: case 13: case 34: case 92:&#x0D;&#x0A; result += Escapes[charCode];&#x0D;&#x0A; break;&#x0D;&#x0A; default:&#x0D;&#x0A; if (charCode &lt; 32) {&#x0D;&#x0A; result += unicodePrefix + toPaddedString(2, charCode.toString(16));&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; result += useCharIndex ? symbols[index] : value.charAt(index);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return result + &apos;&quot;&apos;;&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Recursively serializes an object. Implements the&#x0D;&#x0A; // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.&#x0D;&#x0A; var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {&#x0D;&#x0A; var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;&#x0D;&#x0A; try {&#x0D;&#x0A; // Necessary for host object support.&#x0D;&#x0A; value = object[property];&#x0D;&#x0A; } catch (exception) {}&#x0D;&#x0A; if (typeof value == &quot;object&quot; &amp;&amp; value) {&#x0D;&#x0A; className = getClass.call(value);&#x0D;&#x0A; if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {&#x0D;&#x0A; if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {&#x0D;&#x0A; // Dates are serialized according to the `Date#toJSON` method&#x0D;&#x0A; // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15&#x0D;&#x0A; // for the ISO 8601 date time string format.&#x0D;&#x0A; if (getDay) {&#x0D;&#x0A; // Manually compute the year, month, date, hours, minutes,&#x0D;&#x0A; // seconds, and milliseconds if the `getUTC*` methods are&#x0D;&#x0A; // buggy. Adapted from @Yaffle&apos;s `date-shim` project.&#x0D;&#x0A; date = floor(value / 864e5);&#x0D;&#x0A; for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);&#x0D;&#x0A; for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);&#x0D;&#x0A; date = 1 + date - getDay(year, month);&#x0D;&#x0A; // The `time` value specifies the time within the day (see ES&#x0D;&#x0A; // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used&#x0D;&#x0A; // to compute `A modulo B`, as the `%` operator does not&#x0D;&#x0A; // correspond to the `modulo` operation for negative numbers.&#x0D;&#x0A; time = (value % 864e5 + 864e5) % 864e5;&#x0D;&#x0A; // The hours, minutes, seconds, and milliseconds are obtained by&#x0D;&#x0A; // decomposing the time within the day. See section 15.9.1.10.&#x0D;&#x0A; hours = floor(time / 36e5) % 24;&#x0D;&#x0A; minutes = floor(time / 6e4) % 60;&#x0D;&#x0A; seconds = floor(time / 1e3) % 60;&#x0D;&#x0A; milliseconds = time % 1e3;&#x0D;&#x0A; } else {&#x0D;&#x0A; year = value.getUTCFullYear();&#x0D;&#x0A; month = value.getUTCMonth();&#x0D;&#x0A; date = value.getUTCDate();&#x0D;&#x0A; hours = value.getUTCHours();&#x0D;&#x0A; minutes = value.getUTCMinutes();&#x0D;&#x0A; seconds = value.getUTCSeconds();&#x0D;&#x0A; milliseconds = value.getUTCMilliseconds();&#x0D;&#x0A; }&#x0D;&#x0A; // Serialize extended years correctly.&#x0D;&#x0A; value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +&#x0D;&#x0A; &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +&#x0D;&#x0A; // Months, dates, hours, minutes, and seconds should have two&#x0D;&#x0A; // digits; milliseconds should have three.&#x0D;&#x0A; &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +&#x0D;&#x0A; // Milliseconds are optional in ES 5.0, but required in 5.1.&#x0D;&#x0A; &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;&#x0D;&#x0A; } else {&#x0D;&#x0A; value = null;&#x0D;&#x0A; }&#x0D;&#x0A; } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {&#x0D;&#x0A; // Prototype &lt;= 1.6.1 adds non-standard `toJSON` methods to the&#x0D;&#x0A; // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3&#x0D;&#x0A; // ignores all `toJSON` methods on these objects unless they are&#x0D;&#x0A; // defined directly on an instance.&#x0D;&#x0A; value = value.toJSON(property);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; if (callback) {&#x0D;&#x0A; // If a replacement function was provided, call it to obtain the value&#x0D;&#x0A; // for serialization.&#x0D;&#x0A; value = callback.call(object, property, value);&#x0D;&#x0A; }&#x0D;&#x0A; if (value === null) {&#x0D;&#x0A; return &quot;null&quot;;&#x0D;&#x0A; }&#x0D;&#x0A; className = getClass.call(value);&#x0D;&#x0A; if (className == booleanClass) {&#x0D;&#x0A; // Booleans are represented literally.&#x0D;&#x0A; return &quot;&quot; + value;&#x0D;&#x0A; } else if (className == numberClass) {&#x0D;&#x0A; // JSON numbers must be finite. `Infinity` and `NaN` are serialized as&#x0D;&#x0A; // `&quot;null&quot;`.&#x0D;&#x0A; return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;&#x0D;&#x0A; } else if (className == stringClass) {&#x0D;&#x0A; // Strings are double-quoted and escaped.&#x0D;&#x0A; return quote(&quot;&quot; + value);&#x0D;&#x0A; }&#x0D;&#x0A; // Recursively serialize objects and arrays.&#x0D;&#x0A; if (typeof value == &quot;object&quot;) {&#x0D;&#x0A; // Check for cyclic structures. This is a linear search; performance&#x0D;&#x0A; // is inversely proportional to the number of unique nested objects.&#x0D;&#x0A; for (length = stack.length; length--;) {&#x0D;&#x0A; if (stack[length] === value) {&#x0D;&#x0A; // Cyclic structures cannot be serialized by `JSON.stringify`.&#x0D;&#x0A; throw TypeError();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Add the object to the stack of traversed objects.&#x0D;&#x0A; stack.push(value);&#x0D;&#x0A; results = [];&#x0D;&#x0A; // Save the current indentation level and indent one additional level.&#x0D;&#x0A; prefix = indentation;&#x0D;&#x0A; indentation += whitespace;&#x0D;&#x0A; if (className == arrayClass) {&#x0D;&#x0A; // Recursively serialize array elements.&#x0D;&#x0A; for (index = 0, length = value.length; index &lt; length; index++) {&#x0D;&#x0A; element = serialize(index, value, callback, properties, whitespace, indentation, stack);&#x0D;&#x0A; results.push(element === undef ? &quot;null&quot; : element);&#x0D;&#x0A; }&#x0D;&#x0A; result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;&#x0D;&#x0A; } else {&#x0D;&#x0A; // Recursively serialize object members. Members are selected from&#x0D;&#x0A; // either a user-specified list of property names, or the object&#x0D;&#x0A; // itself.&#x0D;&#x0A; forEach(properties || value, function (property) {&#x0D;&#x0A; var element = serialize(property, value, callback, properties, whitespace, indentation, stack);&#x0D;&#x0A; if (element !== undef) {&#x0D;&#x0A; // According to ES 5.1 section 15.12.3: &quot;If `gap` {whitespace}&#x0D;&#x0A; // is not the empty string, let `member` {quote(property) + &quot;:&quot;}&#x0D;&#x0A; // be the concatenation of `member` and the `space` character.&quot;&#x0D;&#x0A; // The &quot;`space` character&quot; refers to the literal space&#x0D;&#x0A; // character, not the `space` {width} argument provided to&#x0D;&#x0A; // `JSON.stringify`.&#x0D;&#x0A; results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);&#x0D;&#x0A; }&#x0D;&#x0A; });&#x0D;&#x0A; result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;&#x0D;&#x0A; }&#x0D;&#x0A; // Remove the object from the traversed object stack.&#x0D;&#x0A; stack.pop();&#x0D;&#x0A; return result;&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.&#x0D;&#x0A; exports.stringify = function (source, filter, width) {&#x0D;&#x0A; var whitespace, callback, properties, className;&#x0D;&#x0A; if (objectTypes[typeof filter] &amp;&amp; filter) {&#x0D;&#x0A; if ((className = getClass.call(filter)) == functionClass) {&#x0D;&#x0A; callback = filter;&#x0D;&#x0A; } else if (className == arrayClass) {&#x0D;&#x0A; // Convert the property names array into a makeshift set.&#x0D;&#x0A; properties = {};&#x0D;&#x0A; for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; if (width) {&#x0D;&#x0A; if ((className = getClass.call(width)) == numberClass) {&#x0D;&#x0A; // Convert the `width` to an integer and create a string containing&#x0D;&#x0A; // `width` number of space characters.&#x0D;&#x0A; if ((width -= width % 1) &gt; 0) {&#x0D;&#x0A; for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);&#x0D;&#x0A; }&#x0D;&#x0A; } else if (className == stringClass) {&#x0D;&#x0A; whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Opera &lt;= 7.54u2 discards the values associated with empty string keys&#x0D;&#x0A; // (`&quot;&quot;`) only if they are used directly within an object member list&#x0D;&#x0A; // (e.g., `!(&quot;&quot; in { &quot;&quot;: 1})`).&#x0D;&#x0A; return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // Public: Parses a JSON source string.&#x0D;&#x0A; if (!has(&quot;json-parse&quot;)) {&#x0D;&#x0A; var fromCharCode = String.fromCharCode;&#x0D;&#x0A;&#x0D;&#x0A; // Internal: A map of escaped control characters and their unescaped&#x0D;&#x0A; // equivalents.&#x0D;&#x0A; var Unescapes = {&#x0D;&#x0A; 92: &quot;\\&quot;,&#x0D;&#x0A; 34: &apos;&quot;&apos;,&#x0D;&#x0A; 47: &quot;/&quot;,&#x0D;&#x0A; 98: &quot;\b&quot;,&#x0D;&#x0A; 116: &quot;\t&quot;,&#x0D;&#x0A; 110: &quot;\n&quot;,&#x0D;&#x0A; 102: &quot;\f&quot;,&#x0D;&#x0A; 114: &quot;\r&quot;&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Stores the parser state.&#x0D;&#x0A; var Index, Source;&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Resets the parser state and throws a `SyntaxError`.&#x0D;&#x0A; var abort = function () {&#x0D;&#x0A; Index = Source = null;&#x0D;&#x0A; throw SyntaxError();&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Returns the next token, or `&quot;$&quot;` if the parser has reached&#x0D;&#x0A; // the end of the source string. A token may be a string, number, `null`&#x0D;&#x0A; // literal, or Boolean literal.&#x0D;&#x0A; var lex = function () {&#x0D;&#x0A; var source = Source, length = source.length, value, begin, position, isSigned, charCode;&#x0D;&#x0A; while (Index &lt; length) {&#x0D;&#x0A; charCode = source.charCodeAt(Index);&#x0D;&#x0A; switch (charCode) {&#x0D;&#x0A; case 9: case 10: case 13: case 32:&#x0D;&#x0A; // Skip whitespace tokens, including tabs, carriage returns, line&#x0D;&#x0A; // feeds, and space characters.&#x0D;&#x0A; Index++;&#x0D;&#x0A; break;&#x0D;&#x0A; case 123: case 125: case 91: case 93: case 58: case 44:&#x0D;&#x0A; // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at&#x0D;&#x0A; // the current position.&#x0D;&#x0A; value = charIndexBuggy ? source.charAt(Index) : source[Index];&#x0D;&#x0A; Index++;&#x0D;&#x0A; return value;&#x0D;&#x0A; case 34:&#x0D;&#x0A; // `&quot;` delimits a JSON string; advance to the next character and&#x0D;&#x0A; // begin parsing the string. String tokens are prefixed with the&#x0D;&#x0A; // sentinel `@` character to distinguish them from punctuators and&#x0D;&#x0A; // end-of-string tokens.&#x0D;&#x0A; for (value = &quot;@&quot;, Index++; Index &lt; length;) {&#x0D;&#x0A; charCode = source.charCodeAt(Index);&#x0D;&#x0A; if (charCode &lt; 32) {&#x0D;&#x0A; // Unescaped ASCII control characters (those with a code unit&#x0D;&#x0A; // less than the space character) are not permitted.&#x0D;&#x0A; abort();&#x0D;&#x0A; } else if (charCode == 92) {&#x0D;&#x0A; // A reverse solidus (`\`) marks the beginning of an escaped&#x0D;&#x0A; // control character (including `&quot;`, `\`, and `/`) or Unicode&#x0D;&#x0A; // escape sequence.&#x0D;&#x0A; charCode = source.charCodeAt(++Index);&#x0D;&#x0A; switch (charCode) {&#x0D;&#x0A; case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:&#x0D;&#x0A; // Revive escaped control characters.&#x0D;&#x0A; value += Unescapes[charCode];&#x0D;&#x0A; Index++;&#x0D;&#x0A; break;&#x0D;&#x0A; case 117:&#x0D;&#x0A; // `\u` marks the beginning of a Unicode escape sequence.&#x0D;&#x0A; // Advance to the first character and validate the&#x0D;&#x0A; // four-digit code point.&#x0D;&#x0A; begin = ++Index;&#x0D;&#x0A; for (position = Index + 4; Index &lt; position; Index++) {&#x0D;&#x0A; charCode = source.charCodeAt(Index);&#x0D;&#x0A; // A valid sequence comprises four hexdigits (case-&#x0D;&#x0A; // insensitive) that form a single hexadecimal value.&#x0D;&#x0A; if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {&#x0D;&#x0A; // Invalid Unicode escape sequence.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Revive the escaped character.&#x0D;&#x0A; value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));&#x0D;&#x0A; break;&#x0D;&#x0A; default:&#x0D;&#x0A; // Invalid escape sequence.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; } else {&#x0D;&#x0A; if (charCode == 34) {&#x0D;&#x0A; // An unescaped double-quote character marks the end of the&#x0D;&#x0A; // string.&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; charCode = source.charCodeAt(Index);&#x0D;&#x0A; begin = Index;&#x0D;&#x0A; // Optimize for the common case where a string is valid.&#x0D;&#x0A; while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {&#x0D;&#x0A; charCode = source.charCodeAt(++Index);&#x0D;&#x0A; }&#x0D;&#x0A; // Append the string as-is.&#x0D;&#x0A; value += source.slice(begin, Index);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; if (source.charCodeAt(Index) == 34) {&#x0D;&#x0A; // Advance to the next character and return the revived string.&#x0D;&#x0A; Index++;&#x0D;&#x0A; return value;&#x0D;&#x0A; }&#x0D;&#x0A; // Unterminated string.&#x0D;&#x0A; abort();&#x0D;&#x0A; default:&#x0D;&#x0A; // Parse numbers and literals.&#x0D;&#x0A; begin = Index;&#x0D;&#x0A; // Advance past the negative sign, if one is specified.&#x0D;&#x0A; if (charCode == 45) {&#x0D;&#x0A; isSigned = true;&#x0D;&#x0A; charCode = source.charCodeAt(++Index);&#x0D;&#x0A; }&#x0D;&#x0A; // Parse an integer or floating-point value.&#x0D;&#x0A; if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {&#x0D;&#x0A; // Leading zeroes are interpreted as octal literals.&#x0D;&#x0A; if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {&#x0D;&#x0A; // Illegal octal literal.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; isSigned = false;&#x0D;&#x0A; // Parse the integer component.&#x0D;&#x0A; for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);&#x0D;&#x0A; // Floats cannot contain a leading decimal point; however, this&#x0D;&#x0A; // case is already accounted for by the parser.&#x0D;&#x0A; if (source.charCodeAt(Index) == 46) {&#x0D;&#x0A; position = ++Index;&#x0D;&#x0A; // Parse the decimal component.&#x0D;&#x0A; for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);&#x0D;&#x0A; if (position == Index) {&#x0D;&#x0A; // Illegal trailing decimal.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; Index = position;&#x0D;&#x0A; }&#x0D;&#x0A; // Parse exponents. The `e` denoting the exponent is&#x0D;&#x0A; // case-insensitive.&#x0D;&#x0A; charCode = source.charCodeAt(Index);&#x0D;&#x0A; if (charCode == 101 || charCode == 69) {&#x0D;&#x0A; charCode = source.charCodeAt(++Index);&#x0D;&#x0A; // Skip past the sign following the exponent, if one is&#x0D;&#x0A; // specified.&#x0D;&#x0A; if (charCode == 43 || charCode == 45) {&#x0D;&#x0A; Index++;&#x0D;&#x0A; }&#x0D;&#x0A; // Parse the exponential component.&#x0D;&#x0A; for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);&#x0D;&#x0A; if (position == Index) {&#x0D;&#x0A; // Illegal empty exponent.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; Index = position;&#x0D;&#x0A; }&#x0D;&#x0A; // Coerce the parsed value to a JavaScript number.&#x0D;&#x0A; return +source.slice(begin, Index);&#x0D;&#x0A; }&#x0D;&#x0A; // A negative sign may only precede numbers.&#x0D;&#x0A; if (isSigned) {&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; // `true`, `false`, and `null` literals.&#x0D;&#x0A; if (source.slice(Index, Index + 4) == &quot;true&quot;) {&#x0D;&#x0A; Index += 4;&#x0D;&#x0A; return true;&#x0D;&#x0A; } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {&#x0D;&#x0A; Index += 5;&#x0D;&#x0A; return false;&#x0D;&#x0A; } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {&#x0D;&#x0A; Index += 4;&#x0D;&#x0A; return null;&#x0D;&#x0A; }&#x0D;&#x0A; // Unrecognized token.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Return the sentinel `$` character if the parser has reached the end&#x0D;&#x0A; // of the source string.&#x0D;&#x0A; return &quot;$&quot;;&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Parses a JSON `value` token.&#x0D;&#x0A; var get = function (value) {&#x0D;&#x0A; var results, hasMembers;&#x0D;&#x0A; if (value == &quot;$&quot;) {&#x0D;&#x0A; // Unexpected end of input.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; if (typeof value == &quot;string&quot;) {&#x0D;&#x0A; if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {&#x0D;&#x0A; // Remove the sentinel `@` character.&#x0D;&#x0A; return value.slice(1);&#x0D;&#x0A; }&#x0D;&#x0A; // Parse object and array literals.&#x0D;&#x0A; if (value == &quot;[&quot;) {&#x0D;&#x0A; // Parses a JSON array, returning a new JavaScript array.&#x0D;&#x0A; results = [];&#x0D;&#x0A; for (;; hasMembers || (hasMembers = true)) {&#x0D;&#x0A; value = lex();&#x0D;&#x0A; // A closing square bracket marks the end of the array literal.&#x0D;&#x0A; if (value == &quot;]&quot;) {&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; // If the array literal contains elements, the current token&#x0D;&#x0A; // should be a comma separating the previous element from the&#x0D;&#x0A; // next.&#x0D;&#x0A; if (hasMembers) {&#x0D;&#x0A; if (value == &quot;,&quot;) {&#x0D;&#x0A; value = lex();&#x0D;&#x0A; if (value == &quot;]&quot;) {&#x0D;&#x0A; // Unexpected trailing `,` in array literal.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; } else {&#x0D;&#x0A; // A `,` must separate each array element.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Elisions and leading commas are not permitted.&#x0D;&#x0A; if (value == &quot;,&quot;) {&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; results.push(get(value));&#x0D;&#x0A; }&#x0D;&#x0A; return results;&#x0D;&#x0A; } else if (value == &quot;{&quot;) {&#x0D;&#x0A; // Parses a JSON object, returning a new JavaScript object.&#x0D;&#x0A; results = {};&#x0D;&#x0A; for (;; hasMembers || (hasMembers = true)) {&#x0D;&#x0A; value = lex();&#x0D;&#x0A; // A closing curly brace marks the end of the object literal.&#x0D;&#x0A; if (value == &quot;}&quot;) {&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; // If the object literal contains members, the current token&#x0D;&#x0A; // should be a comma separator.&#x0D;&#x0A; if (hasMembers) {&#x0D;&#x0A; if (value == &quot;,&quot;) {&#x0D;&#x0A; value = lex();&#x0D;&#x0A; if (value == &quot;}&quot;) {&#x0D;&#x0A; // Unexpected trailing `,` in object literal.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; } else {&#x0D;&#x0A; // A `,` must separate each object member.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; // Leading commas are not permitted, object property names must be&#x0D;&#x0A; // double-quoted strings, and a `:` must separate each property&#x0D;&#x0A; // name and value.&#x0D;&#x0A; if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; results[value.slice(1)] = get(lex());&#x0D;&#x0A; }&#x0D;&#x0A; return results;&#x0D;&#x0A; }&#x0D;&#x0A; // Unexpected token encountered.&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; return value;&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Updates a traversed object member.&#x0D;&#x0A; var update = function (source, property, callback) {&#x0D;&#x0A; var element = walk(source, property, callback);&#x0D;&#x0A; if (element === undef) {&#x0D;&#x0A; delete source[property];&#x0D;&#x0A; } else {&#x0D;&#x0A; source[property] = element;&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Internal: Recursively traverses a parsed JSON object, invoking the&#x0D;&#x0A; // `callback` function for each value. This is an implementation of the&#x0D;&#x0A; // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.&#x0D;&#x0A; var walk = function (source, property, callback) {&#x0D;&#x0A; var value = source[property], length;&#x0D;&#x0A; if (typeof value == &quot;object&quot; &amp;&amp; value) {&#x0D;&#x0A; // `forEach` can&apos;t be used to traverse an array in Opera &lt;= 8.54&#x0D;&#x0A; // because its `Object#hasOwnProperty` implementation returns `false`&#x0D;&#x0A; // for array indices (e.g., `![1, 2, 3].hasOwnProperty(&quot;0&quot;)`).&#x0D;&#x0A; if (getClass.call(value) == arrayClass) {&#x0D;&#x0A; for (length = value.length; length--;) {&#x0D;&#x0A; update(value, length, callback);&#x0D;&#x0A; }&#x0D;&#x0A; } else {&#x0D;&#x0A; forEach(value, function (property) {&#x0D;&#x0A; update(value, property, callback);&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; return callback.call(source, property, value);&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; // Public: `JSON.parse`. See ES 5.1 section 15.12.2.&#x0D;&#x0A; exports.parse = function (source, callback) {&#x0D;&#x0A; var result, value;&#x0D;&#x0A; Index = 0;&#x0D;&#x0A; Source = &quot;&quot; + source;&#x0D;&#x0A; result = get(lex());&#x0D;&#x0A; // If a JSON string contains multiple tokens, it is invalid.&#x0D;&#x0A; if (lex() != &quot;$&quot;) {&#x0D;&#x0A; abort();&#x0D;&#x0A; }&#x0D;&#x0A; // Reset the parser state.&#x0D;&#x0A; Index = Source = null;&#x0D;&#x0A; return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; exports[&quot;runInContext&quot;] = runInContext;&#x0D;&#x0A; return exports;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (freeExports &amp;&amp; !isLoader) {&#x0D;&#x0A; // Export for CommonJS environments.&#x0D;&#x0A; runInContext(root, freeExports);&#x0D;&#x0A; } else {&#x0D;&#x0A; // Export for web browsers and JavaScript engines.&#x0D;&#x0A; var nativeJSON = root.JSON,&#x0D;&#x0A; previousJSON = root[&quot;JSON3&quot;],&#x0D;&#x0A; isRestored = false;&#x0D;&#x0A;&#x0D;&#x0A; var JSON3 = runInContext(root, (root[&quot;JSON3&quot;] = {&#x0D;&#x0A; // Public: Restores the original value of the global `JSON` object and&#x0D;&#x0A; // returns a reference to the `JSON3` object.&#x0D;&#x0A; &quot;noConflict&quot;: function () {&#x0D;&#x0A; if (!isRestored) {&#x0D;&#x0A; isRestored = true;&#x0D;&#x0A; root.JSON = nativeJSON;&#x0D;&#x0A; root[&quot;JSON3&quot;] = previousJSON;&#x0D;&#x0A; nativeJSON = previousJSON = null;&#x0D;&#x0A; }&#x0D;&#x0A; return JSON3;&#x0D;&#x0A; }&#x0D;&#x0A; }));&#x0D;&#x0A;&#x0D;&#x0A; root.JSON = {&#x0D;&#x0A; &quot;parse&quot;: JSON3.parse,&#x0D;&#x0A; &quot;stringify&quot;: JSON3.stringify&#x0D;&#x0A; };&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // Export for asynchronous module loaders.&#x0D;&#x0A; if (isLoader) {&#x0D;&#x0A; define(function () {&#x0D;&#x0A; return JSON3;&#x0D;&#x0A; });&#x0D;&#x0A; }&#x0D;&#x0A;}).call(this);&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{}],35:[function(_dereq_,module,exports){&#x0D;&#x0A;/**&#x0D;&#x0A; * Helpers.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var s = 1000;&#x0D;&#x0A;var m = s * 60;&#x0D;&#x0A;var h = m * 60;&#x0D;&#x0A;var d = h * 24;&#x0D;&#x0A;var y = d * 365.25;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Parse or format the given `val`.&#x0D;&#x0A; *&#x0D;&#x0A; * Options:&#x0D;&#x0A; *&#x0D;&#x0A; * - `long` verbose formatting [false]&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String|Number} val&#x0D;&#x0A; * @param {Object} options&#x0D;&#x0A; * @return {String|Number}&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function(val, options){&#x0D;&#x0A; options = options || {};&#x0D;&#x0A; if (&apos;string&apos; == typeof val) return parse(val);&#x0D;&#x0A; return options.long&#x0D;&#x0A; ? long(val)&#x0D;&#x0A; : short(val);&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Parse the given `str` and return milliseconds.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} str&#x0D;&#x0A; * @return {Number}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function parse(str) {&#x0D;&#x0A; str = &apos;&apos; + str;&#x0D;&#x0A; if (str.length &gt; 10000) return;&#x0D;&#x0A; var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);&#x0D;&#x0A; if (!match) return;&#x0D;&#x0A; var n = parseFloat(match[1]);&#x0D;&#x0A; var type = (match[2] || &apos;ms&apos;).toLowerCase();&#x0D;&#x0A; switch (type) {&#x0D;&#x0A; case &apos;years&apos;:&#x0D;&#x0A; case &apos;year&apos;:&#x0D;&#x0A; case &apos;yrs&apos;:&#x0D;&#x0A; case &apos;yr&apos;:&#x0D;&#x0A; case &apos;y&apos;:&#x0D;&#x0A; return n * y;&#x0D;&#x0A; case &apos;days&apos;:&#x0D;&#x0A; case &apos;day&apos;:&#x0D;&#x0A; case &apos;d&apos;:&#x0D;&#x0A; return n * d;&#x0D;&#x0A; case &apos;hours&apos;:&#x0D;&#x0A; case &apos;hour&apos;:&#x0D;&#x0A; case &apos;hrs&apos;:&#x0D;&#x0A; case &apos;hr&apos;:&#x0D;&#x0A; case &apos;h&apos;:&#x0D;&#x0A; return n * h;&#x0D;&#x0A; case &apos;minutes&apos;:&#x0D;&#x0A; case &apos;minute&apos;:&#x0D;&#x0A; case &apos;mins&apos;:&#x0D;&#x0A; case &apos;min&apos;:&#x0D;&#x0A; case &apos;m&apos;:&#x0D;&#x0A; return n * m;&#x0D;&#x0A; case &apos;seconds&apos;:&#x0D;&#x0A; case &apos;second&apos;:&#x0D;&#x0A; case &apos;secs&apos;:&#x0D;&#x0A; case &apos;sec&apos;:&#x0D;&#x0A; case &apos;s&apos;:&#x0D;&#x0A; return n * s;&#x0D;&#x0A; case &apos;milliseconds&apos;:&#x0D;&#x0A; case &apos;millisecond&apos;:&#x0D;&#x0A; case &apos;msecs&apos;:&#x0D;&#x0A; case &apos;msec&apos;:&#x0D;&#x0A; case &apos;ms&apos;:&#x0D;&#x0A; return n;&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Short format for `ms`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Number} ms&#x0D;&#x0A; * @return {String}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function short(ms) {&#x0D;&#x0A; if (ms &gt;= d) return Math.round(ms / d) + &apos;d&apos;;&#x0D;&#x0A; if (ms &gt;= h) return Math.round(ms / h) + &apos;h&apos;;&#x0D;&#x0A; if (ms &gt;= m) return Math.round(ms / m) + &apos;m&apos;;&#x0D;&#x0A; if (ms &gt;= s) return Math.round(ms / s) + &apos;s&apos;;&#x0D;&#x0A; return ms + &apos;ms&apos;;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Long format for `ms`.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Number} ms&#x0D;&#x0A; * @return {String}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function long(ms) {&#x0D;&#x0A; return plural(ms, d, &apos;day&apos;)&#x0D;&#x0A; || plural(ms, h, &apos;hour&apos;)&#x0D;&#x0A; || plural(ms, m, &apos;minute&apos;)&#x0D;&#x0A; || plural(ms, s, &apos;second&apos;)&#x0D;&#x0A; || ms + &apos; ms&apos;;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Pluralization helper.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function plural(ms, n, name) {&#x0D;&#x0A; if (ms &lt; n) return;&#x0D;&#x0A; if (ms &lt; n * 1.5) return Math.floor(ms / n) + &apos; &apos; + name;&#x0D;&#x0A; return Math.ceil(ms / n) + &apos; &apos; + name + &apos;s&apos;;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{}],36:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/**&#x0D;&#x0A; * JSON parse.&#x0D;&#x0A; *&#x0D;&#x0A; * @see Based on jQuery#parseJSON (MIT) and JSON2&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var rvalidchars = /^[\],:{}\s]*$/;&#x0D;&#x0A;var rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g;&#x0D;&#x0A;var rvalidtokens = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;&#x0D;&#x0A;var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;&#x0D;&#x0A;var rtrimLeft = /^\s+/;&#x0D;&#x0A;var rtrimRight = /\s+$/;&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function parsejson(data) {&#x0D;&#x0A; if (&apos;string&apos; != typeof data || !data) {&#x0D;&#x0A; return null;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; data = data.replace(rtrimLeft, &apos;&apos;).replace(rtrimRight, &apos;&apos;);&#x0D;&#x0A;&#x0D;&#x0A; // Attempt to parse using the native JSON parser first&#x0D;&#x0A; if (global.JSON &amp;&amp; JSON.parse) {&#x0D;&#x0A; return JSON.parse(data);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (rvalidchars.test(data.replace(rvalidescape, &apos;@&apos;)&#x0D;&#x0A; .replace(rvalidtokens, &apos;]&apos;)&#x0D;&#x0A; .replace(rvalidbraces, &apos;&apos;))) {&#x0D;&#x0A; return (new Function(&apos;return &apos; + data))();&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{}],37:[function(_dereq_,module,exports){&#x0D;&#x0A;/**&#x0D;&#x0A; * Compiles a querystring&#x0D;&#x0A; * Returns string representation of the object&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object}&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.encode = function (obj) {&#x0D;&#x0A; var str = &apos;&apos;;&#x0D;&#x0A;&#x0D;&#x0A; for (var i in obj) {&#x0D;&#x0A; if (obj.hasOwnProperty(i)) {&#x0D;&#x0A; if (str.length) str += &apos;&amp;&apos;;&#x0D;&#x0A; str += encodeURIComponent(i) + &apos;=&apos; + encodeURIComponent(obj[i]);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return str;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Parses a simple querystring into an object&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} qs&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.decode = function(qs){&#x0D;&#x0A; var qry = {};&#x0D;&#x0A; var pairs = qs.split(&apos;&amp;&apos;);&#x0D;&#x0A; for (var i = 0, l = pairs.length; i &lt; l; i++) {&#x0D;&#x0A; var pair = pairs[i].split(&apos;=&apos;);&#x0D;&#x0A; qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);&#x0D;&#x0A; }&#x0D;&#x0A; return qry;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],38:[function(_dereq_,module,exports){&#x0D;&#x0A;/**&#x0D;&#x0A; * Parses an URI&#x0D;&#x0A; *&#x0D;&#x0A; * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;&#x0D;&#x0A;&#x0D;&#x0A;var parts = [&#x0D;&#x0A; &apos;source&apos;, &apos;protocol&apos;, &apos;authority&apos;, &apos;userInfo&apos;, &apos;user&apos;, &apos;password&apos;, &apos;host&apos;, &apos;port&apos;, &apos;relative&apos;, &apos;path&apos;, &apos;directory&apos;, &apos;file&apos;, &apos;query&apos;, &apos;anchor&apos;&#x0D;&#x0A;];&#x0D;&#x0A;&#x0D;&#x0A;module.exports = function parseuri(str) {&#x0D;&#x0A; var src = str,&#x0D;&#x0A; b = str.indexOf(&apos;[&apos;),&#x0D;&#x0A; e = str.indexOf(&apos;]&apos;);&#x0D;&#x0A;&#x0D;&#x0A; if (b != -1 &amp;&amp; e != -1) {&#x0D;&#x0A; str = str.substring(0, b) + str.substring(b, e).replace(/:/g, &apos;;&apos;) + str.substring(e, str.length);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var m = re.exec(str || &apos;&apos;),&#x0D;&#x0A; uri = {},&#x0D;&#x0A; i = 14;&#x0D;&#x0A;&#x0D;&#x0A; while (i--) {&#x0D;&#x0A; uri[parts[i]] = m[i] || &apos;&apos;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; if (b != -1 &amp;&amp; e != -1) {&#x0D;&#x0A; uri.source = src;&#x0D;&#x0A; uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, &apos;:&apos;);&#x0D;&#x0A; uri.authority = uri.authority.replace(&apos;[&apos;, &apos;&apos;).replace(&apos;]&apos;, &apos;&apos;).replace(/;/g, &apos;:&apos;);&#x0D;&#x0A; uri.ipv6uri = true;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return uri;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;},{}],39:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/*global Blob,File*/&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module requirements&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var isArray = _dereq_(&apos;isarray&apos;);&#x0D;&#x0A;var isBuf = _dereq_(&apos;./is-buffer&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.&#x0D;&#x0A; * Anything with blobs or files should be fed through removeBlobs before coming&#x0D;&#x0A; * here.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet - socket.io event packet&#x0D;&#x0A; * @return {Object} with deconstructed packet and list of buffers&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.deconstructPacket = function(packet){&#x0D;&#x0A; var buffers = [];&#x0D;&#x0A; var packetData = packet.data;&#x0D;&#x0A;&#x0D;&#x0A; function _deconstructPacket(data) {&#x0D;&#x0A; if (!data) return data;&#x0D;&#x0A;&#x0D;&#x0A; if (isBuf(data)) {&#x0D;&#x0A; var placeholder = { _placeholder: true, num: buffers.length };&#x0D;&#x0A; buffers.push(data);&#x0D;&#x0A; return placeholder;&#x0D;&#x0A; } else if (isArray(data)) {&#x0D;&#x0A; var newData = new Array(data.length);&#x0D;&#x0A; for (var i = 0; i &lt; data.length; i++) {&#x0D;&#x0A; newData[i] = _deconstructPacket(data[i]);&#x0D;&#x0A; }&#x0D;&#x0A; return newData;&#x0D;&#x0A; } else if (&apos;object&apos; == typeof data &amp;&amp; !(data instanceof Date)) {&#x0D;&#x0A; var newData = {};&#x0D;&#x0A; for (var key in data) {&#x0D;&#x0A; newData[key] = _deconstructPacket(data[key]);&#x0D;&#x0A; }&#x0D;&#x0A; return newData;&#x0D;&#x0A; }&#x0D;&#x0A; return data;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var pack = packet;&#x0D;&#x0A; pack.data = _deconstructPacket(packetData);&#x0D;&#x0A; pack.attachments = buffers.length; // number of binary &apos;attachments&apos;&#x0D;&#x0A; return {packet: pack, buffers: buffers};&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Reconstructs a binary packet from its placeholder packet and buffers&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet - event packet with placeholders&#x0D;&#x0A; * @param {Array} buffers - binary buffers to put in placeholder positions&#x0D;&#x0A; * @return {Object} reconstructed packet&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.reconstructPacket = function(packet, buffers) {&#x0D;&#x0A; var curPlaceHolder = 0;&#x0D;&#x0A;&#x0D;&#x0A; function _reconstructPacket(data) {&#x0D;&#x0A; if (data &amp;&amp; data._placeholder) {&#x0D;&#x0A; var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)&#x0D;&#x0A; return buf;&#x0D;&#x0A; } else if (isArray(data)) {&#x0D;&#x0A; for (var i = 0; i &lt; data.length; i++) {&#x0D;&#x0A; data[i] = _reconstructPacket(data[i]);&#x0D;&#x0A; }&#x0D;&#x0A; return data;&#x0D;&#x0A; } else if (data &amp;&amp; &apos;object&apos; == typeof data) {&#x0D;&#x0A; for (var key in data) {&#x0D;&#x0A; data[key] = _reconstructPacket(data[key]);&#x0D;&#x0A; }&#x0D;&#x0A; return data;&#x0D;&#x0A; }&#x0D;&#x0A; return data;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; packet.data = _reconstructPacket(packet.data);&#x0D;&#x0A; packet.attachments = undefined; // no longer useful&#x0D;&#x0A; return packet;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Asynchronously removes Blobs or Files from data via&#x0D;&#x0A; * FileReader&apos;s readAsArrayBuffer method. Used before encoding&#x0D;&#x0A; * data as msgpack. Calls callback with the blobless data.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} data&#x0D;&#x0A; * @param {Function} callback&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.removeBlobs = function(data, callback) {&#x0D;&#x0A; function _removeBlobs(obj, curKey, containingObject) {&#x0D;&#x0A; if (!obj) return obj;&#x0D;&#x0A;&#x0D;&#x0A; // convert any blob&#x0D;&#x0A; if ((global.Blob &amp;&amp; obj instanceof Blob) ||&#x0D;&#x0A; (global.File &amp;&amp; obj instanceof File)) {&#x0D;&#x0A; pendingBlobs++;&#x0D;&#x0A;&#x0D;&#x0A; // async filereader&#x0D;&#x0A; var fileReader = new FileReader();&#x0D;&#x0A; fileReader.onload = function() { // this.result == arraybuffer&#x0D;&#x0A; if (containingObject) {&#x0D;&#x0A; containingObject[curKey] = this.result;&#x0D;&#x0A; }&#x0D;&#x0A; else {&#x0D;&#x0A; bloblessData = this.result;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // if nothing pending its callback time&#x0D;&#x0A; if(! --pendingBlobs) {&#x0D;&#x0A; callback(bloblessData);&#x0D;&#x0A; }&#x0D;&#x0A; };&#x0D;&#x0A;&#x0D;&#x0A; fileReader.readAsArrayBuffer(obj); // blob -&gt; arraybuffer&#x0D;&#x0A; } else if (isArray(obj)) { // handle array&#x0D;&#x0A; for (var i = 0; i &lt; obj.length; i++) {&#x0D;&#x0A; _removeBlobs(obj[i], i, obj);&#x0D;&#x0A; }&#x0D;&#x0A; } else if (obj &amp;&amp; &apos;object&apos; == typeof obj &amp;&amp; !isBuf(obj)) { // and object&#x0D;&#x0A; for (var key in obj) {&#x0D;&#x0A; _removeBlobs(obj[key], key, obj);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; var pendingBlobs = 0;&#x0D;&#x0A; var bloblessData = data;&#x0D;&#x0A; _removeBlobs(bloblessData);&#x0D;&#x0A; if (!pendingBlobs) {&#x0D;&#x0A; callback(bloblessData);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{&quot;./is-buffer&quot;:41,&quot;isarray&quot;:33}],40:[function(_dereq_,module,exports){&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Module dependencies.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;var debug = _dereq_(&apos;debug&apos;)(&apos;socket.io-parser&apos;);&#x0D;&#x0A;var json = _dereq_(&apos;json3&apos;);&#x0D;&#x0A;var isArray = _dereq_(&apos;isarray&apos;);&#x0D;&#x0A;var Emitter = _dereq_(&apos;component-emitter&apos;);&#x0D;&#x0A;var binary = _dereq_(&apos;./binary&apos;);&#x0D;&#x0A;var isBuf = _dereq_(&apos;./is-buffer&apos;);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Protocol version.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.protocol = 4;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet types.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.types = [&#x0D;&#x0A; &apos;CONNECT&apos;,&#x0D;&#x0A; &apos;DISCONNECT&apos;,&#x0D;&#x0A; &apos;EVENT&apos;,&#x0D;&#x0A; &apos;ACK&apos;,&#x0D;&#x0A; &apos;ERROR&apos;,&#x0D;&#x0A; &apos;BINARY_EVENT&apos;,&#x0D;&#x0A; &apos;BINARY_ACK&apos;&#x0D;&#x0A;];&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet type `connect`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.CONNECT = 0;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet type `disconnect`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.DISCONNECT = 1;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet type `event`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.EVENT = 2;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet type `ack`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.ACK = 3;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet type `error`.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.ERROR = 4;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet type &apos;binary event&apos;&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.BINARY_EVENT = 5;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Packet type `binary ack`. For acks with binary arguments.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.BINARY_ACK = 6;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encoder constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.Encoder = Encoder;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Decoder constructor.&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;exports.Decoder = Decoder;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * A socket.io Encoder instance&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Encoder() {}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encode a packet as a single string if non-binary, or as a&#x0D;&#x0A; * buffer sequence, depending on packet type.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} obj - packet object&#x0D;&#x0A; * @param {Function} callback - function to handle encodings (likely engine.write)&#x0D;&#x0A; * @return Calls callback with Array of encodings&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Encoder.prototype.encode = function(obj, callback){&#x0D;&#x0A; debug(&apos;encoding packet %j&apos;, obj);&#x0D;&#x0A;&#x0D;&#x0A; if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {&#x0D;&#x0A; encodeAsBinary(obj, callback);&#x0D;&#x0A; }&#x0D;&#x0A; else {&#x0D;&#x0A; var encoding = encodeAsString(obj);&#x0D;&#x0A; callback([encoding]);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encode packet as string.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @return {String} encoded&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function encodeAsString(obj) {&#x0D;&#x0A; var str = &apos;&apos;;&#x0D;&#x0A; var nsp = false;&#x0D;&#x0A;&#x0D;&#x0A; // first is type&#x0D;&#x0A; str += obj.type;&#x0D;&#x0A;&#x0D;&#x0A; // attachments if we have them&#x0D;&#x0A; if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {&#x0D;&#x0A; str += obj.attachments;&#x0D;&#x0A; str += &apos;-&apos;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // if we have a namespace other than `/`&#x0D;&#x0A; // we append it followed by a comma `,`&#x0D;&#x0A; if (obj.nsp &amp;&amp; &apos;/&apos; != obj.nsp) {&#x0D;&#x0A; nsp = true;&#x0D;&#x0A; str += obj.nsp;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // immediately followed by the id&#x0D;&#x0A; if (null != obj.id) {&#x0D;&#x0A; if (nsp) {&#x0D;&#x0A; str += &apos;,&apos;;&#x0D;&#x0A; nsp = false;&#x0D;&#x0A; }&#x0D;&#x0A; str += obj.id;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // json data&#x0D;&#x0A; if (null != obj.data) {&#x0D;&#x0A; if (nsp) str += &apos;,&apos;;&#x0D;&#x0A; str += json.stringify(obj.data);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;encoded %j as %s&apos;, obj, str);&#x0D;&#x0A; return str;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Encode packet as &apos;buffer sequence&apos; by removing blobs, and&#x0D;&#x0A; * deconstructing packet into object with placeholders and&#x0D;&#x0A; * a list of buffers.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @return {Buffer} encoded&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function encodeAsBinary(obj, callback) {&#x0D;&#x0A;&#x0D;&#x0A; function writeEncoding(bloblessData) {&#x0D;&#x0A; var deconstruction = binary.deconstructPacket(bloblessData);&#x0D;&#x0A; var pack = encodeAsString(deconstruction.packet);&#x0D;&#x0A; var buffers = deconstruction.buffers;&#x0D;&#x0A;&#x0D;&#x0A; buffers.unshift(pack); // add packet info to beginning of data list&#x0D;&#x0A; callback(buffers); // write all the buffers&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; binary.removeBlobs(obj, writeEncoding);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * A socket.io Decoder instance&#x0D;&#x0A; *&#x0D;&#x0A; * @return {Object} decoder&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function Decoder() {&#x0D;&#x0A; this.reconstructor = null;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Mix in `Emitter` with Decoder.&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Emitter(Decoder.prototype);&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Decodes an ecoded packet string into packet JSON.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} obj - encoded packet&#x0D;&#x0A; * @return {Object} packet&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Decoder.prototype.add = function(obj) {&#x0D;&#x0A; var packet;&#x0D;&#x0A; if (&apos;string&apos; == typeof obj) {&#x0D;&#x0A; packet = decodeString(obj);&#x0D;&#x0A; if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet&apos;s json&#x0D;&#x0A; this.reconstructor = new BinaryReconstructor(packet);&#x0D;&#x0A;&#x0D;&#x0A; // no attachments, labeled binary but no binary data to follow&#x0D;&#x0A; if (this.reconstructor.reconPack.attachments === 0) {&#x0D;&#x0A; this.emit(&apos;decoded&apos;, packet);&#x0D;&#x0A; }&#x0D;&#x0A; } else { // non-binary full packet&#x0D;&#x0A; this.emit(&apos;decoded&apos;, packet);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; else if (isBuf(obj) || obj.base64) { // raw binary data&#x0D;&#x0A; if (!this.reconstructor) {&#x0D;&#x0A; throw new Error(&apos;got binary data when not reconstructing a packet&apos;);&#x0D;&#x0A; } else {&#x0D;&#x0A; packet = this.reconstructor.takeBinaryData(obj);&#x0D;&#x0A; if (packet) { // received final buffer&#x0D;&#x0A; this.reconstructor = null;&#x0D;&#x0A; this.emit(&apos;decoded&apos;, packet);&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A; else {&#x0D;&#x0A; throw new Error(&apos;Unknown type: &apos; + obj);&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Decode a packet String (JSON data)&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} str&#x0D;&#x0A; * @return {Object} packet&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function decodeString(str) {&#x0D;&#x0A; var p = {};&#x0D;&#x0A; var i = 0;&#x0D;&#x0A;&#x0D;&#x0A; // look up type&#x0D;&#x0A; p.type = Number(str.charAt(0));&#x0D;&#x0A; if (null == exports.types[p.type]) return error();&#x0D;&#x0A;&#x0D;&#x0A; // look up attachments if type binary&#x0D;&#x0A; if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {&#x0D;&#x0A; var buf = &apos;&apos;;&#x0D;&#x0A; while (str.charAt(++i) != &apos;-&apos;) {&#x0D;&#x0A; buf += str.charAt(i);&#x0D;&#x0A; if (i == str.length) break;&#x0D;&#x0A; }&#x0D;&#x0A; if (buf != Number(buf) || str.charAt(i) != &apos;-&apos;) {&#x0D;&#x0A; throw new Error(&apos;Illegal attachments&apos;);&#x0D;&#x0A; }&#x0D;&#x0A; p.attachments = Number(buf);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // look up namespace (if any)&#x0D;&#x0A; if (&apos;/&apos; == str.charAt(i + 1)) {&#x0D;&#x0A; p.nsp = &apos;&apos;;&#x0D;&#x0A; while (++i) {&#x0D;&#x0A; var c = str.charAt(i);&#x0D;&#x0A; if (&apos;,&apos; == c) break;&#x0D;&#x0A; p.nsp += c;&#x0D;&#x0A; if (i == str.length) break;&#x0D;&#x0A; }&#x0D;&#x0A; } else {&#x0D;&#x0A; p.nsp = &apos;/&apos;;&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // look up id&#x0D;&#x0A; var next = str.charAt(i + 1);&#x0D;&#x0A; if (&apos;&apos; !== next &amp;&amp; Number(next) == next) {&#x0D;&#x0A; p.id = &apos;&apos;;&#x0D;&#x0A; while (++i) {&#x0D;&#x0A; var c = str.charAt(i);&#x0D;&#x0A; if (null == c || Number(c) != c) {&#x0D;&#x0A; --i;&#x0D;&#x0A; break;&#x0D;&#x0A; }&#x0D;&#x0A; p.id += str.charAt(i);&#x0D;&#x0A; if (i == str.length) break;&#x0D;&#x0A; }&#x0D;&#x0A; p.id = Number(p.id);&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; // look up json data&#x0D;&#x0A; if (str.charAt(++i)) {&#x0D;&#x0A; try {&#x0D;&#x0A; p.data = json.parse(str.substr(i));&#x0D;&#x0A; } catch(e){&#x0D;&#x0A; return error();&#x0D;&#x0A; }&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; debug(&apos;decoded %s as %j&apos;, str, p);&#x0D;&#x0A; return p;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Deallocates a parser&apos;s resources&#x0D;&#x0A; *&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;Decoder.prototype.destroy = function() {&#x0D;&#x0A; if (this.reconstructor) {&#x0D;&#x0A; this.reconstructor.finishedReconstruction();&#x0D;&#x0A; }&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * A manager of a binary event&apos;s &apos;buffer sequence&apos;. Should&#x0D;&#x0A; * be constructed whenever a packet of type BINARY_EVENT is&#x0D;&#x0A; * decoded.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Object} packet&#x0D;&#x0A; * @return {BinaryReconstructor} initialized reconstructor&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function BinaryReconstructor(packet) {&#x0D;&#x0A; this.reconPack = packet;&#x0D;&#x0A; this.buffers = [];&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Method to be called when binary data received from connection&#x0D;&#x0A; * after a BINARY_EVENT packet.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Buffer | ArrayBuffer} binData - the raw binary data received&#x0D;&#x0A; * @return {null | Object} returns null if more binary data is expected or&#x0D;&#x0A; * a reconstructed packet object if all buffers have been received.&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;BinaryReconstructor.prototype.takeBinaryData = function(binData) {&#x0D;&#x0A; this.buffers.push(binData);&#x0D;&#x0A; if (this.buffers.length == this.reconPack.attachments) { // done with buffer list&#x0D;&#x0A; var packet = binary.reconstructPacket(this.reconPack, this.buffers);&#x0D;&#x0A; this.finishedReconstruction();&#x0D;&#x0A; return packet;&#x0D;&#x0A; }&#x0D;&#x0A; return null;&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Cleans up binary packet reconstruction variables.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;BinaryReconstructor.prototype.finishedReconstruction = function() {&#x0D;&#x0A; this.reconPack = null;&#x0D;&#x0A; this.buffers = [];&#x0D;&#x0A;};&#x0D;&#x0A;&#x0D;&#x0A;function error(data){&#x0D;&#x0A; return {&#x0D;&#x0A; type: exports.ERROR,&#x0D;&#x0A; data: &apos;parser error&apos;&#x0D;&#x0A; };&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{&quot;./binary&quot;:39,&quot;./is-buffer&quot;:41,&quot;component-emitter&quot;:42,&quot;debug&quot;:14,&quot;isarray&quot;:33,&quot;json3&quot;:34}],41:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;&#x0D;&#x0A;module.exports = isBuf;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Returns true if obj is a buffer or an arraybuffer.&#x0D;&#x0A; *&#x0D;&#x0A; * @api private&#x0D;&#x0A; */&#x0D;&#x0A;&#x0D;&#x0A;function isBuf(obj) {&#x0D;&#x0A; return (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||&#x0D;&#x0A; (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{}],42:[function(_dereq_,module,exports){&#x0D;&#x0A;arguments[4][26][0].apply(exports,arguments)&#x0D;&#x0A;},{&quot;dup&quot;:26}],43:[function(_dereq_,module,exports){&#x0D;&#x0A;module.exports = toArray&#x0D;&#x0A;&#x0D;&#x0A;function toArray(list, index) {&#x0D;&#x0A; var array = []&#x0D;&#x0A;&#x0D;&#x0A; index = index || 0&#x0D;&#x0A;&#x0D;&#x0A; for (var i = index || 0; i &lt; list.length; i++) {&#x0D;&#x0A; array[i - index] = list[i]&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return array&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;},{}],44:[function(_dereq_,module,exports){&#x0D;&#x0A;(function (global){&#x0D;&#x0A;/*! https://mths.be/utf8js v2.0.0 by @mathias */&#x0D;&#x0A;;(function(root) {&#x0D;&#x0A;&#x0D;&#x0A;&#x09;// Detect free variables `exports`&#x0D;&#x0A;&#x09;var freeExports = typeof exports == &apos;object&apos; &amp;&amp; exports;&#x0D;&#x0A;&#x0D;&#x0A;&#x09;// Detect free variable `module`&#x0D;&#x0A;&#x09;var freeModule = typeof module == &apos;object&apos; &amp;&amp; module &amp;&amp;&#x0D;&#x0A;&#x09;&#x09;module.exports == freeExports &amp;&amp; module;&#x0D;&#x0A;&#x0D;&#x0A;&#x09;// Detect free variable `global`, from Node.js or Browserified code,&#x0D;&#x0A;&#x09;// and use it as `root`&#x0D;&#x0A;&#x09;var freeGlobal = typeof global == &apos;object&apos; &amp;&amp; global;&#x0D;&#x0A;&#x09;if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {&#x0D;&#x0A;&#x09;&#x09;root = freeGlobal;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;/*--------------------------------------------------------------------------*/&#x0D;&#x0A;&#x0D;&#x0A;&#x09;var stringFromCharCode = String.fromCharCode;&#x0D;&#x0A;&#x0D;&#x0A;&#x09;// Taken from https://mths.be/punycode&#x0D;&#x0A;&#x09;function ucs2decode(string) {&#x0D;&#x0A;&#x09;&#x09;var output = [];&#x0D;&#x0A;&#x09;&#x09;var counter = 0;&#x0D;&#x0A;&#x09;&#x09;var length = string.length;&#x0D;&#x0A;&#x09;&#x09;var value;&#x0D;&#x0A;&#x09;&#x09;var extra;&#x0D;&#x0A;&#x09;&#x09;while (counter &lt; length) {&#x0D;&#x0A;&#x09;&#x09;&#x09;value = string.charCodeAt(counter++);&#x0D;&#x0A;&#x09;&#x09;&#x09;if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;// high surrogate, and there is a next character&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;extra = string.charCodeAt(counter++);&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;} else {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;// unmatched surrogate; only append this code unit, in case the next&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;// code unit is the high surrogate of a surrogate pair&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;output.push(value);&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;counter--;&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;&#x09;} else {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;output.push(value);&#x0D;&#x0A;&#x09;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;return output;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;// Taken from https://mths.be/punycode&#x0D;&#x0A;&#x09;function ucs2encode(array) {&#x0D;&#x0A;&#x09;&#x09;var length = array.length;&#x0D;&#x0A;&#x09;&#x09;var index = -1;&#x0D;&#x0A;&#x09;&#x09;var value;&#x0D;&#x0A;&#x09;&#x09;var output = &apos;&apos;;&#x0D;&#x0A;&#x09;&#x09;while (++index &lt; length) {&#x0D;&#x0A;&#x09;&#x09;&#x09;value = array[index];&#x0D;&#x0A;&#x09;&#x09;&#x09;if (value &gt; 0xFFFF) {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;value -= 0x10000;&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;value = 0xDC00 | value &amp; 0x3FF;&#x0D;&#x0A;&#x09;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;&#x09;output += stringFromCharCode(value);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;return output;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;function checkScalarValue(codePoint) {&#x0D;&#x0A;&#x09;&#x09;if (codePoint &gt;= 0xD800 &amp;&amp; codePoint &lt;= 0xDFFF) {&#x0D;&#x0A;&#x09;&#x09;&#x09;throw Error(&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;&apos;Lone surrogate U+&apos; + codePoint.toString(16).toUpperCase() +&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;&apos; is not a scalar value&apos;&#x0D;&#x0A;&#x09;&#x09;&#x09;);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x09;/*--------------------------------------------------------------------------*/&#x0D;&#x0A;&#x0D;&#x0A;&#x09;function createByte(codePoint, shift) {&#x0D;&#x0A;&#x09;&#x09;return stringFromCharCode(((codePoint &gt;&gt; shift) &amp; 0x3F) | 0x80);&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;function encodeCodePoint(codePoint) {&#x0D;&#x0A;&#x09;&#x09;if ((codePoint &amp; 0xFFFFFF80) == 0) { // 1-byte sequence&#x0D;&#x0A;&#x09;&#x09;&#x09;return stringFromCharCode(codePoint);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;var symbol = &apos;&apos;;&#x0D;&#x0A;&#x09;&#x09;if ((codePoint &amp; 0xFFFFF800) == 0) { // 2-byte sequence&#x0D;&#x0A;&#x09;&#x09;&#x09;symbol = stringFromCharCode(((codePoint &gt;&gt; 6) &amp; 0x1F) | 0xC0);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;else if ((codePoint &amp; 0xFFFF0000) == 0) { // 3-byte sequence&#x0D;&#x0A;&#x09;&#x09;&#x09;checkScalarValue(codePoint);&#x0D;&#x0A;&#x09;&#x09;&#x09;symbol = stringFromCharCode(((codePoint &gt;&gt; 12) &amp; 0x0F) | 0xE0);&#x0D;&#x0A;&#x09;&#x09;&#x09;symbol += createByte(codePoint, 6);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;else if ((codePoint &amp; 0xFFE00000) == 0) { // 4-byte sequence&#x0D;&#x0A;&#x09;&#x09;&#x09;symbol = stringFromCharCode(((codePoint &gt;&gt; 18) &amp; 0x07) | 0xF0);&#x0D;&#x0A;&#x09;&#x09;&#x09;symbol += createByte(codePoint, 12);&#x0D;&#x0A;&#x09;&#x09;&#x09;symbol += createByte(codePoint, 6);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;symbol += stringFromCharCode((codePoint &amp; 0x3F) | 0x80);&#x0D;&#x0A;&#x09;&#x09;return symbol;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;function utf8encode(string) {&#x0D;&#x0A;&#x09;&#x09;var codePoints = ucs2decode(string);&#x0D;&#x0A;&#x09;&#x09;var length = codePoints.length;&#x0D;&#x0A;&#x09;&#x09;var index = -1;&#x0D;&#x0A;&#x09;&#x09;var codePoint;&#x0D;&#x0A;&#x09;&#x09;var byteString = &apos;&apos;;&#x0D;&#x0A;&#x09;&#x09;while (++index &lt; length) {&#x0D;&#x0A;&#x09;&#x09;&#x09;codePoint = codePoints[index];&#x0D;&#x0A;&#x09;&#x09;&#x09;byteString += encodeCodePoint(codePoint);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;return byteString;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;/*--------------------------------------------------------------------------*/&#x0D;&#x0A;&#x0D;&#x0A;&#x09;function readContinuationByte() {&#x0D;&#x0A;&#x09;&#x09;if (byteIndex &gt;= byteCount) {&#x0D;&#x0A;&#x09;&#x09;&#x09;throw Error(&apos;Invalid byte index&apos;);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;var continuationByte = byteArray[byteIndex] &amp; 0xFF;&#x0D;&#x0A;&#x09;&#x09;byteIndex++;&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;if ((continuationByte &amp; 0xC0) == 0x80) {&#x0D;&#x0A;&#x09;&#x09;&#x09;return continuationByte &amp; 0x3F;&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;// If we end up here, it’s not a continuation byte&#x0D;&#x0A;&#x09;&#x09;throw Error(&apos;Invalid continuation byte&apos;);&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;function decodeSymbol() {&#x0D;&#x0A;&#x09;&#x09;var byte1;&#x0D;&#x0A;&#x09;&#x09;var byte2;&#x0D;&#x0A;&#x09;&#x09;var byte3;&#x0D;&#x0A;&#x09;&#x09;var byte4;&#x0D;&#x0A;&#x09;&#x09;var codePoint;&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;if (byteIndex &gt; byteCount) {&#x0D;&#x0A;&#x09;&#x09;&#x09;throw Error(&apos;Invalid byte index&apos;);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;if (byteIndex == byteCount) {&#x0D;&#x0A;&#x09;&#x09;&#x09;return false;&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;// Read first byte&#x0D;&#x0A;&#x09;&#x09;byte1 = byteArray[byteIndex] &amp; 0xFF;&#x0D;&#x0A;&#x09;&#x09;byteIndex++;&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;// 1-byte sequence (no continuation bytes)&#x0D;&#x0A;&#x09;&#x09;if ((byte1 &amp; 0x80) == 0) {&#x0D;&#x0A;&#x09;&#x09;&#x09;return byte1;&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;// 2-byte sequence&#x0D;&#x0A;&#x09;&#x09;if ((byte1 &amp; 0xE0) == 0xC0) {&#x0D;&#x0A;&#x09;&#x09;&#x09;var byte2 = readContinuationByte();&#x0D;&#x0A;&#x09;&#x09;&#x09;codePoint = ((byte1 &amp; 0x1F) &lt;&lt; 6) | byte2;&#x0D;&#x0A;&#x09;&#x09;&#x09;if (codePoint &gt;= 0x80) {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;return codePoint;&#x0D;&#x0A;&#x09;&#x09;&#x09;} else {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;throw Error(&apos;Invalid continuation byte&apos;);&#x0D;&#x0A;&#x09;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;// 3-byte sequence (may include unpaired surrogates)&#x0D;&#x0A;&#x09;&#x09;if ((byte1 &amp; 0xF0) == 0xE0) {&#x0D;&#x0A;&#x09;&#x09;&#x09;byte2 = readContinuationByte();&#x0D;&#x0A;&#x09;&#x09;&#x09;byte3 = readContinuationByte();&#x0D;&#x0A;&#x09;&#x09;&#x09;codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 12) | (byte2 &lt;&lt; 6) | byte3;&#x0D;&#x0A;&#x09;&#x09;&#x09;if (codePoint &gt;= 0x0800) {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;checkScalarValue(codePoint);&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;return codePoint;&#x0D;&#x0A;&#x09;&#x09;&#x09;} else {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;throw Error(&apos;Invalid continuation byte&apos;);&#x0D;&#x0A;&#x09;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;// 4-byte sequence&#x0D;&#x0A;&#x09;&#x09;if ((byte1 &amp; 0xF8) == 0xF0) {&#x0D;&#x0A;&#x09;&#x09;&#x09;byte2 = readContinuationByte();&#x0D;&#x0A;&#x09;&#x09;&#x09;byte3 = readContinuationByte();&#x0D;&#x0A;&#x09;&#x09;&#x09;byte4 = readContinuationByte();&#x0D;&#x0A;&#x09;&#x09;&#x09;codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 0x12) | (byte2 &lt;&lt; 0x0C) |&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;(byte3 &lt;&lt; 0x06) | byte4;&#x0D;&#x0A;&#x09;&#x09;&#x09;if (codePoint &gt;= 0x010000 &amp;&amp; codePoint &lt;= 0x10FFFF) {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;return codePoint;&#x0D;&#x0A;&#x09;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;&#x09;throw Error(&apos;Invalid UTF-8 detected&apos;);&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;var byteArray;&#x0D;&#x0A;&#x09;var byteCount;&#x0D;&#x0A;&#x09;var byteIndex;&#x0D;&#x0A;&#x09;function utf8decode(byteString) {&#x0D;&#x0A;&#x09;&#x09;byteArray = ucs2decode(byteString);&#x0D;&#x0A;&#x09;&#x09;byteCount = byteArray.length;&#x0D;&#x0A;&#x09;&#x09;byteIndex = 0;&#x0D;&#x0A;&#x09;&#x09;var codePoints = [];&#x0D;&#x0A;&#x09;&#x09;var tmp;&#x0D;&#x0A;&#x09;&#x09;while ((tmp = decodeSymbol()) !== false) {&#x0D;&#x0A;&#x09;&#x09;&#x09;codePoints.push(tmp);&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;return ucs2encode(codePoints);&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;&#x09;/*--------------------------------------------------------------------------*/&#x0D;&#x0A;&#x0D;&#x0A;&#x09;var utf8 = {&#x0D;&#x0A;&#x09;&#x09;&apos;version&apos;: &apos;2.0.0&apos;,&#x0D;&#x0A;&#x09;&#x09;&apos;encode&apos;: utf8encode,&#x0D;&#x0A;&#x09;&#x09;&apos;decode&apos;: utf8decode&#x0D;&#x0A;&#x09;};&#x0D;&#x0A;&#x0D;&#x0A;&#x09;// Some AMD build optimizers, like r.js, check for specific condition patterns&#x0D;&#x0A;&#x09;// like the following:&#x0D;&#x0A;&#x09;if (&#x0D;&#x0A;&#x09;&#x09;typeof define == &apos;function&apos; &amp;&amp;&#x0D;&#x0A;&#x09;&#x09;typeof define.amd == &apos;object&apos; &amp;&amp;&#x0D;&#x0A;&#x09;&#x09;define.amd&#x0D;&#x0A;&#x09;) {&#x0D;&#x0A;&#x09;&#x09;define(function() {&#x0D;&#x0A;&#x09;&#x09;&#x09;return utf8;&#x0D;&#x0A;&#x09;&#x09;});&#x0D;&#x0A;&#x09;}&#x09;else if (freeExports &amp;&amp; !freeExports.nodeType) {&#x0D;&#x0A;&#x09;&#x09;if (freeModule) { // in Node.js or RingoJS v0.8.0+&#x0D;&#x0A;&#x09;&#x09;&#x09;freeModule.exports = utf8;&#x0D;&#x0A;&#x09;&#x09;} else { // in Narwhal or RingoJS v0.7.0-&#x0D;&#x0A;&#x09;&#x09;&#x09;var object = {};&#x0D;&#x0A;&#x09;&#x09;&#x09;var hasOwnProperty = object.hasOwnProperty;&#x0D;&#x0A;&#x09;&#x09;&#x09;for (var key in utf8) {&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;hasOwnProperty.call(utf8, key) &amp;&amp; (freeExports[key] = utf8[key]);&#x0D;&#x0A;&#x09;&#x09;&#x09;}&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;&#x09;} else { // in Rhino or a web browser&#x0D;&#x0A;&#x09;&#x09;root.utf8 = utf8;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x0D;&#x0A;}(this));&#x0D;&#x0A;&#x0D;&#x0A;}).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})&#x0D;&#x0A;},{}],45:[function(_dereq_,module,exports){&#x0D;&#x0A;&apos;use strict&apos;;&#x0D;&#x0A;&#x0D;&#x0A;var alphabet = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_&apos;.split(&apos;&apos;)&#x0D;&#x0A; , length = 64&#x0D;&#x0A; , map = {}&#x0D;&#x0A; , seed = 0&#x0D;&#x0A; , i = 0&#x0D;&#x0A; , prev;&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Return a string representing the specified number.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {Number} num The number to convert.&#x0D;&#x0A; * @returns {String} The string representation of the number.&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;function encode(num) {&#x0D;&#x0A; var encoded = &apos;&apos;;&#x0D;&#x0A;&#x0D;&#x0A; do {&#x0D;&#x0A; encoded = alphabet[num % length] + encoded;&#x0D;&#x0A; num = Math.floor(num / length);&#x0D;&#x0A; } while (num &gt; 0);&#x0D;&#x0A;&#x0D;&#x0A; return encoded;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Return the integer value specified by the given string.&#x0D;&#x0A; *&#x0D;&#x0A; * @param {String} str The string to convert.&#x0D;&#x0A; * @returns {Number} The integer value represented by the string.&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;function decode(str) {&#x0D;&#x0A; var decoded = 0;&#x0D;&#x0A;&#x0D;&#x0A; for (i = 0; i &lt; str.length; i++) {&#x0D;&#x0A; decoded = decoded * length + map[str.charAt(i)];&#x0D;&#x0A; }&#x0D;&#x0A;&#x0D;&#x0A; return decoded;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/**&#x0D;&#x0A; * Yeast: A tiny growing id generator.&#x0D;&#x0A; *&#x0D;&#x0A; * @returns {String} A unique id.&#x0D;&#x0A; * @api public&#x0D;&#x0A; */&#x0D;&#x0A;function yeast() {&#x0D;&#x0A; var now = encode(+new Date());&#x0D;&#x0A;&#x0D;&#x0A; if (now !== prev) return seed = 0, prev = now;&#x0D;&#x0A; return now +&apos;.&apos;+ encode(seed++);&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;//&#x0D;&#x0A;// Map each character to its index.&#x0D;&#x0A;//&#x0D;&#x0A;for (; i &lt; length; i++) map[alphabet[i]] = i;&#x0D;&#x0A;&#x0D;&#x0A;//&#x0D;&#x0A;// Expose the `yeast`, `encode` and `decode` functions.&#x0D;&#x0A;//&#x0D;&#x0A;yeast.encode = encode;&#x0D;&#x0A;yeast.decode = decode;&#x0D;&#x0A;module.exports = yeast;&#x0D;&#x0A;&#x0D;&#x0A;},{}]},{},[1])(1)&#x0D;&#x0A;});&#x0D;&#x0A;</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment></comment>
                    <comment2>Initialisation de connection via SocketIO</comment2>
                </event>
                <event disabled="true" folded="true">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="DepartScene" />
                            <parameters>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="true" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>socket = io.connect(&apos;https://gdevelop.herokuapp.com&apos;);</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment></comment>
                    <comment2>Interaction avec le serveur</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="DepartScene" />
                            <parameters>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="ModVarScene" />
                            <parameters>
                                <parameter>loop_count</parameter>
                                <parameter>=</parameter>
                                <parameter>0</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="109" g="230" r="255" textB="0" textG="0" textR="0" />
                    <comment></comment>
                    <comment2>Reception provenant du serveur</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                            <parameters />
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>socket.on(&apos;message&apos;, function(message) {&#x0D;&#x0A;&#x09;//alert(&apos;Le serveur a un message pour vous : &apos; + message);&#x0D;&#x0A;&#x0D;&#x0A;&#x09;//var game = runtimeScene.getGame();&#x0D;&#x0A;&#x09;//var variables = game.getVariables();&#x0D;&#x0A;&#x09;var server_message = variables.get(&quot;server_message&quot;);&#x0D;&#x0A;&#x09;server_message.setString(message);&#x0D;&#x0A;&#x0D;&#x0A;&#x0D;&#x0A;})</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions />
                    <actions>
                        <action>
                            <type inverted="false" value="TextObject::String" />
                            <parameters>
                                <parameter>output_server</parameter>
                                <parameter>=</parameter>
                                <parameter>GlobalVariableString(server_message)</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="109" g="230" r="255" textB="0" textG="0" textR="0" />
                    <comment></comment>
                    <comment2>Envoi au serveur</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="SourisSurObjet" />
                            <parameters>
                                <parameter>btn</parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                        <condition>
                            <type inverted="false" value="SourisBouton" />
                            <parameters>
                                <parameter></parameter>
                                <parameter>Left</parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                        <condition>
                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                            <parameters />
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::Standard</type>
                            <conditions>
                                <condition>
                                    <type inverted="false" value="VarObjetTxt" />
                                    <parameters>
                                        <parameter>btn</parameter>
                                        <parameter>type</parameter>
                                        <parameter>=</parameter>
                                        <parameter>&quot;send_data&quot;</parameter>
                                    </parameters>
                                    <subConditions />
                                </condition>
                            </conditions>
                            <actions />
                            <events>
                                <event disabled="false" folded="false">
                                    <type>BuiltinCommonInstructions::JsCode</type>
                                    <inlineCode>socket.emit(&apos;message&apos;, &apos;Salut serveur, ça va ?&apos;);</inlineCode>
                                    <parameterObjects></parameterObjects>
                                </event>
                                <event disabled="false" folded="false">
                                    <type>BuiltinCommonInstructions::Standard</type>
                                    <conditions />
                                    <actions />
                                    <events />
                                </event>
                            </events>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="109" g="230" r="255" textB="0" textG="0" textR="0" />
                    <comment></comment>
                    <comment2>init</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Link</type>
                    <include end="-1" includeAll="true" start="-1" />
                    <target>Evenements externes</target>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="109" g="230" r="255" textB="0" textG="0" textR="0" />
                    <comment></comment>
                    <comment2>q</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                            <parameters />
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::Repeat</type>
                            <repeatExpression>2</repeatExpression>
                            <conditions />
                            <actions />
                            <events />
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                            <parameters />
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>//game = runtimeScene.getGame();&#x0D;&#x0A;//variables = game.getVariables();&#x0D;&#x0A;joueurs = variables.get(&quot;joueurs&quot;);&#x0D;&#x0A;&#x0D;&#x0A;//console.log(joueurs);&#x0D;&#x0A;&#x0D;&#x0A;child = joueurs.getAllChildren();&#x0D;&#x0A;&#x0D;&#x0A;var count = 0;&#x0D;&#x0A;for (var k in child) {&#x0D;&#x0A; if (child.hasOwnProperty(k)) {&#x0D;&#x0A; ++count;&#x0D;&#x0A; }&#x0D;&#x0A;}&#x0D;&#x0A;console.log(&quot;Enfant : &quot; + count );&#x0D;&#x0A;&#x0D;&#x0A;var nb_joueurs = variables.get(&quot;nb_joueurs&quot;);&#x0D;&#x0A;nb_joueurs.setString(count);</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions />
                    <actions />
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Repeat</type>
                    <repeatExpression>GlobalVariable(nb_joueurs)</repeatExpression>
                    <conditions>
                        <condition>
                            <type inverted="false" value="BuiltinCommonInstructions::Once" />
                            <parameters />
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>loop_count = variables.get(&quot;loop_count&quot;);&#x0D;&#x0A;loop_count_value = loop_count.getAsNumber();&#x0D;&#x0A;console.log(loop_count_value + &quot; : loop_count&quot;);&#x0D;&#x0A;loop_count.setNumber(loop_count_value + 1);</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                        <event disabled="true" folded="false">
                            <type>BuiltinCommonInstructions::Standard</type>
                            <conditions />
                            <actions>
                                <action>
                                    <type inverted="false" value="ModVarScene" />
                                    <parameters>
                                        <parameter>loop_count</parameter>
                                        <parameter>+</parameter>
                                        <parameter>1</parameter>
                                    </parameters>
                                    <subActions />
                                </action>
                            </actions>
                            <events />
                        </event>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::Standard</type>
                            <conditions />
                            <actions>
                                <action>
                                    <type inverted="false" value="Create" />
                                    <parameters>
                                        <parameter></parameter>
                                        <parameter>Joueur</parameter>
                                        <parameter>Random(200)</parameter>
                                        <parameter>Random(200)</parameter>
                                        <parameter></parameter>
                                    </parameters>
                                    <subActions />
                                </action>
                                <action>
                                    <type inverted="false" value="ChangeAnimation" />
                                    <parameters>
                                        <parameter>Joueur</parameter>
                                        <parameter>=</parameter>
                                        <parameter>Random(3)</parameter>
                                    </parameters>
                                    <subActions />
                                </action>
                                <action>
                                    <type inverted="false" value="ModVarObjetTxt" />
                                    <parameters>
                                        <parameter>Joueur</parameter>
                                        <parameter>joueur_1.pseudo</parameter>
                                        <parameter>=</parameter>
                                        <parameter>&quot;tims_&quot; + GlobalVariableString(loop_count_value)</parameter>
                                    </parameters>
                                    <subActions />
                                </action>
                            </actions>
                            <events />
                        </event>
                    </events>
                </event>
            </events>
            <layers>
                <layer name="" visibility="true">
                    <cameras>
                        <camera defaultSize="true" defaultViewport="true" height="0.000000" viewportBottom="1.000000" viewportLeft="0.000000" viewportRight="1.000000" viewportTop="0.000000" width="0.000000" />
                    </cameras>
                    <effects />
                </layer>
            </layers>
            <behaviorsSharedData />
        </layout>
    </layouts>
    <externalEvents>
        <externalEvents associatedLayout="jeux" lastChangeTimeStamp="1470753425" name="Evenements externes">
            <events>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment>Cette liste d&apos;évènement est importé dans les deux scènes</comment>
                    <comment2>This list of event is imported in two scenes</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment>Connections clients/serveur</comment>
                    <comment2></comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="DepartScene" />
                            <parameters>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions />
                    <events>
                        <event disabled="false" folded="false">
                            <type>BuiltinCommonInstructions::JsCode</type>
                            <inlineCode>socket = io.connect(&apos;https://gdevelop.herokuapp.com&apos;);&#x0D;&#x0A;game = runtimeScene.getGame();&#x0D;&#x0A;variables = game.getVariables();</inlineCode>
                            <parameterObjects></parameterObjects>
                        </event>
                    </events>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment>Survol des boutons BTN</comment>
                    <comment2>Hover button BTN</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="true" value="SourisSurObjet" />
                            <parameters>
                                <parameter>btn</parameter>
                                <parameter></parameter>
                                <parameter>oui</parameter>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="ChangeAnimation" />
                            <parameters>
                                <parameter>btn</parameter>
                                <parameter>=</parameter>
                                <parameter>0</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Standard</type>
                    <conditions>
                        <condition>
                            <type inverted="false" value="SourisSurObjet" />
                            <parameters>
                                <parameter>btn</parameter>
                                <parameter></parameter>
                                <parameter>oui</parameter>
                                <parameter></parameter>
                            </parameters>
                            <subConditions />
                        </condition>
                    </conditions>
                    <actions>
                        <action>
                            <type inverted="false" value="ChangeAnimation" />
                            <parameters>
                                <parameter>btn</parameter>
                                <parameter>=</parameter>
                                <parameter>1</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::Comment</type>
                    <color b="255" g="128" r="0" textB="0" textG="0" textR="0" />
                    <comment>Edition des objets Text avec leurs variable d&apos;objet</comment>
                    <comment2>Edit text on Object Text with their variable&apos;s object</comment2>
                </event>
                <event disabled="false" folded="false">
                    <type>BuiltinCommonInstructions::ForEach</type>
                    <object>txt_var</object>
                    <conditions />
                    <actions>
                        <action>
                            <type inverted="false" value="TextObject::String" />
                            <parameters>
                                <parameter>txt_var</parameter>
                                <parameter>=</parameter>
                                <parameter>txt_var.VariableString(text)</parameter>
                            </parameters>
                            <subActions />
                        </action>
                    </actions>
                    <events />
                </event>
            </events>
        </externalEvents>
    </externalEvents>
    <externalLayouts />
    <externalSourceFiles>
        <sourceFile filename="Assets\sourcesJS\socketIO.js" gdManaged="false" language="Javascript" />
    </externalSourceFiles>
</project>
